setfpscap(120)


local Settings = {
    Accent = Color3.fromHex("#4799ad"),
    Font = Enum.Font.SourceSans,
    IsBackgroundTransparent = true,
    Rounded = false,
    Dim = false,
    
    ItemColor = Color3.fromRGB(30, 30, 30),
    BorderColor = Color3.fromRGB(45, 45, 45),
    MinSize = Vector2.new(550, 400),
    MaxSize = Vector2.new(800, 700)
}


local Menu = {}
local Tabs = {}
local Items = {}
local EventObjects = {} -- For updating items on menu property change
local Notifications = {}

local Scaling = {True = false, Origin = nil, Size = nil}
local Dragging = {Gui = nil, True = false}
local Draggables = {}
local ToolTip = {Enabled = false, Content = "", Item = nil}

local HotkeyRemoveKey = Enum.KeyCode.RightControl
local Selected = {
    Frame = nil,
    Item = nil,
    Offset = UDim2.new(),
    Follow = false
}
local SelectedTab
local SelectedTabLines = {}


local wait = task.wait
local delay = task.delay
local spawn = task.spawn
local protect_gui = function(Gui, Parent)
    if gethui and syn and syn.protect_gui then 
        Gui.Parent = gethui() 
    elseif not gethui and syn and syn.protect_gui then 
        syn.protect_gui(Gui)
        Gui.Parent = Parent 
    else 
        Gui.Parent = Parent 
    end
end

local CoreGui = game:GetService("CoreGui")
local UserInput = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local TextService = game:GetService("TextService")
local TweenService = game:GetService("TweenService")


local __Menu = {}
setmetatable(Menu, {
    __index = function(self, Key) return __Menu[Key] end,
    __newindex = function(self, Key, Value)
        __Menu[Key] = Value
        
        if Key == "Hue" or Key == "ScreenSize" then return end

        for _, Object in pairs(EventObjects) do Object:Update() end
        for _, Notification in pairs(Notifications) do Notification:Update() end
    end
})


Menu.Accent = Settings.Accent
Menu.Font = Settings.Font
Menu.IsBackgroundTransparent = Settings.IsBackgroundTransparent
Menu.Rounded = Settings.IsRounded
Menu.Dim = Settings.IsDim
Menu.ItemColor = Settings.ItemColor
Menu.BorderColor = Settings.BorderColor
Menu.MinSize = Settings.MinSize
Menu.MaxSize = Settings.MaxSize

Menu.Hue = 0
Menu.IsVisible = false
Menu.ScreenSize = Vector2.new()


local function AddEventListener(self: GuiObject, Update: any)
    table.insert(EventObjects, {
        self = self,
        Update = Update
    })
end


local function CreateCorner(Parent: Instance, Pixels: number): UICorner
    local UICorner = Instance.new("UICorner")
    UICorner.Name = "Corner"
    UICorner.Parent = Parent
    return UICorner
end


local function CreateStroke(Parent: Instance, Color: Color3, Thickness: number, Transparency: number): UIStroke
    local UIStroke = Instance.new("UIStroke")
    UIStroke.Name = "Stroke"
    UIStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
    UIStroke.LineJoinMode = Enum.LineJoinMode.Miter
    UIStroke.Color = Color or Color3.new()
    UIStroke.Thickness = Thickness or 1
    UIStroke.Transparency = Transparency or 0
    UIStroke.Enabled = true
    UIStroke.Parent = Parent
    return UIStroke
end 


local function CreateLine(Parent: Instance, Size: UDim2, Position: UDim2, Color: Color3): Frame
    local Line = Instance.new("Frame")
    Line.Name = "Line"
    Line.BackgroundColor3 = typeof(Color) == "Color3" and Color or Menu.Accent
    Line.BorderSizePixel = 0
    Line.Size = Size or UDim2.new(1, 0, 0, 1)
    Line.Position = Position or UDim2.new()
    Line.Parent = Parent

    if Line.BackgroundColor3 == Menu.Accent then
        AddEventListener(Line, function() Line.BackgroundColor3 = Menu.Accent end)
    end

    return Line
end


local function CreateLabel(Parent: Instance, Name: string, Text: string, Size: UDim2, Position: UDim2): TextLabel
    local Label = Instance.new("TextLabel")
    Label.Name = Name
    Label.BackgroundTransparency = 1
    Label.Size = Size or UDim2.new(1, 0, 0, 15)
    Label.Position = Position or UDim2.new()
    Label.Font = Enum.Font.SourceSans
    Label.Text = Text or ""
    Label.TextColor3 = Color3.new(1, 1, 1)
    Label.TextSize = 14
    Label.TextXAlignment = Enum.TextXAlignment.Left
    Label.Parent = Parent
    return Label
end


local function UpdateSelected(Frame: Instance, Item: Item, Offset: UDim2)
    local Selected_Frame = Selected.Frame
    if Selected_Frame then
        Selected_Frame.Visible = false
        Selected_Frame.Parent = nil
    end

    Selected = {}

    if Frame then
        if Selected_Frame == Frame then return end
        Selected = {
            Frame = Frame,
            Item = Item,
            Offset = Offset
        }

        Frame.ZIndex = 3
        Frame.Visible = true
        Frame.Parent = Menu.Screen
    end
end


local function SetDraggable(self: GuiObject)
    table.insert(Draggables, self)
    local DragOrigin
    local GuiOrigin

    self.InputBegan:Connect(function(Input: InputObject, Process: boolean)
        if (not Dragging.Gui and not Dragging.True) and (Input.UserInputType == Enum.UserInputType.MouseButton1) then
            for _, v in ipairs(Draggables) do
                v.ZIndex = 1
            end
            self.ZIndex = 2

            Dragging = {Gui = self, True = true}
            DragOrigin = Vector2.new(Input.Position.X, Input.Position.Y)
            GuiOrigin = self.Position
        end
    end)

    UserInput.InputChanged:Connect(function(Input: InputObject, Process: boolean)
        if Dragging.Gui ~= self then return end
        if not (UserInput:IsMouseButtonPressed(Enum.UserInputType.MouseButton1)) then
            Dragging = {Gui = nil, True = false}
            return
        end
        if (Input.UserInputType == Enum.UserInputType.MouseMovement) then
            local Delta = Vector2.new(Input.Position.X, Input.Position.Y) - DragOrigin
            local ScreenSize = Menu.ScreenSize

            local ScaleX = (ScreenSize.X * GuiOrigin.X.Scale)
            local ScaleY = (ScreenSize.Y * GuiOrigin.Y.Scale)
            local OffsetX = math.clamp(GuiOrigin.X.Offset + Delta.X + ScaleX,   0, ScreenSize.X - self.AbsoluteSize.X)
            local OffsetY = math.clamp(GuiOrigin.Y.Offset + Delta.Y + ScaleY, -36, ScreenSize.Y - self.AbsoluteSize.Y)
            
            local Position = UDim2.fromOffset(OffsetX, OffsetY)
			self.Position = Position
        end
    end)
end


Menu.Screen = Instance.new("ScreenGui")
Menu.Screen.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
protect_gui(Menu.Screen, CoreGui)
Menu.ScreenSize = Menu.Screen.AbsoluteSize

local Menu_Frame = Instance.new("Frame")
local MenuScaler_Button = Instance.new("TextButton")
local Title_Label = Instance.new("TextLabel")
local Icon_Image = Instance.new("ImageLabel")
local TabHandler_Frame = Instance.new("Frame")
local TabIndex_Frame = Instance.new("Frame")
local Tabs_Frame = Instance.new("Frame")

local Notifications_Frame = Instance.new("Frame")
local MenuDim_Frame = Instance.new("Frame")
local ToolTip_Label = Instance.new("TextLabel")
local Modal = Instance.new("TextButton")

Menu_Frame.Name = "Menu"
Menu_Frame.BackgroundColor3 = Color3.fromRGB(10, 10, 10)
Menu_Frame.BorderColor3 = Color3.fromRGB(40, 40, 40)
Menu_Frame.BorderMode = Enum.BorderMode.Inset
Menu_Frame.Position = UDim2.new(0.5, -250, 0.5, -275)
Menu_Frame.Size = UDim2.new(0, 500, 0, 550)
Menu_Frame.Visible = false
Menu_Frame.Parent = Menu.Screen
CreateStroke(Menu_Frame, Color3.new(), 2)
CreateLine(Menu_Frame, UDim2.new(1, -8, 0, 1), UDim2.new(0, 4, 0, 15))
SetDraggable(Menu_Frame)

MenuScaler_Button.Name = "MenuScaler"
MenuScaler_Button.BackgroundColor3 = Color3.fromRGB(10, 10, 10)
MenuScaler_Button.BorderColor3 = Color3.fromRGB(40, 40, 40)
MenuScaler_Button.BorderSizePixel = 0
MenuScaler_Button.Position = UDim2.new(1, -15, 1, -15)
MenuScaler_Button.Size = UDim2.fromOffset(15, 15)
MenuScaler_Button.Font = Enum.Font.SourceSans
MenuScaler_Button.Text = ""
MenuScaler_Button.TextColor3 = Color3.new(1, 1, 1)
MenuScaler_Button.TextSize = 14
MenuScaler_Button.AutoButtonColor = false
MenuScaler_Button.Parent = Menu_Frame
MenuScaler_Button.InputBegan:Connect(function(Input, Process)
    if Process then return end
    if (Input.UserInputType == Enum.UserInputType.MouseButton1) then
        UpdateSelected()
        Scaling = {
            True = true,
            Origin = Vector2.new(Input.Position.X, Input.Position.Y),
            Size = Menu_Frame.AbsoluteSize - Vector2.new(0, 36)
        }
    end
end)
MenuScaler_Button.InputEnded:Connect(function(Input, Process)
    if (Input.UserInputType == Enum.UserInputType.MouseButton1) then
        UpdateSelected()
        Scaling = {
            True = false,
            Origin = nil,
            Size = nil
        }
    end
end)

Icon_Image.Name = "Icon"
Icon_Image.BackgroundTransparency = 1
Icon_Image.Position = UDim2.new(0, 5, 0, 0)
Icon_Image.Size = UDim2.fromOffset(15, 15)
Icon_Image.Image = "rbxassetid://"
Icon_Image.Visible = false
Icon_Image.Parent = Menu_Frame

Title_Label.Name = "Title"
Title_Label.BackgroundTransparency = 1
Title_Label.Position = UDim2.new(0, 5, 0, 0)
Title_Label.Size = UDim2.new(1, -10, 0, 15)
Title_Label.Font = Enum.Font.SourceSans
Title_Label.Text = ""
Title_Label.TextColor3 = Color3.new(1, 1, 1)
Title_Label.TextSize = 14
Title_Label.TextXAlignment = Enum.TextXAlignment.Left
Title_Label.RichText = true
Title_Label.Parent = Menu_Frame

TabHandler_Frame.Name = "TabHandler"
TabHandler_Frame.BackgroundColor3 = Color3.fromRGB(15, 15, 15)
TabHandler_Frame.BorderColor3 = Color3.fromRGB(40, 40, 40)
TabHandler_Frame.BorderMode = Enum.BorderMode.Inset
TabHandler_Frame.Position = UDim2.new(0, 4, 0, 19)
TabHandler_Frame.Size = UDim2.new(1, -8, 1, -25)
TabHandler_Frame.Parent = Menu_Frame
CreateStroke(TabHandler_Frame, Color3.new(), 2)

TabIndex_Frame.Name = "TabIndex"
TabIndex_Frame.BackgroundTransparency = 1
TabIndex_Frame.Position = UDim2.new(0, 1, 0, 1)
TabIndex_Frame.Size = UDim2.new(1, -2, 0, 20)
TabIndex_Frame.Parent = TabHandler_Frame

Tabs_Frame.Name = "Tabs"
Tabs_Frame.BackgroundTransparency = 1
Tabs_Frame.Position = UDim2.new(0, 1, 0, 26)
Tabs_Frame.Size = UDim2.new(1, -2, 1, -25)
Tabs_Frame.Parent = TabHandler_Frame

Notifications_Frame.Name = "Notifications"
Notifications_Frame.BackgroundTransparency = 1
Notifications_Frame.Size = UDim2.new(1, 0, 1, 36)
Notifications_Frame.Position = UDim2.fromOffset(0, -36)
Notifications_Frame.ZIndex = 5
Notifications_Frame.Parent = Menu.Screen

ToolTip_Label.Name = "ToolTip"
ToolTip_Label.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
ToolTip_Label.BorderColor3 = Menu.BorderColor
ToolTip_Label.BorderMode = Enum.BorderMode.Inset
ToolTip_Label.AutomaticSize = Enum.AutomaticSize.XY
ToolTip_Label.Size = UDim2.fromOffset(0, 0, 0, 15)
ToolTip_Label.Text = ""
ToolTip_Label.TextSize = 14
ToolTip_Label.Font = Enum.Font.SourceSans
ToolTip_Label.TextColor3 = Color3.new(1, 1, 1)
ToolTip_Label.ZIndex = 5
ToolTip_Label.Visible = false
ToolTip_Label.Parent = Menu.Screen
CreateStroke(ToolTip_Label, Color3.new(), 1)
AddEventListener(ToolTip_Label, function()
    ToolTip_Label.BorderColor3 = Menu.BorderColor
end)

Modal.Name = "Modal"
Modal.BackgroundTransparency = 1
Modal.Modal = true
Modal.Text = ""
Modal.Parent = Menu_Frame


--SelectedTabLines.Top = CreateLine(nil, UDim2.new(1, 0, 0, 1), UDim2.new())
SelectedTabLines.Left = CreateLine(nil, UDim2.new(0, 1, 1, 0), UDim2.new(), Color3.new())
SelectedTabLines.Right = CreateLine(nil, UDim2.new(0, 1, 1, 0), UDim2.new(1, -1, 0, 0), Color3.new())
SelectedTabLines.Bottom = CreateLine(TabIndex_Frame, UDim2.new(), UDim2.new(0, 0, 1, 0), Color3.new())
SelectedTabLines.Bottom2 = CreateLine(TabIndex_Frame, UDim2.new(), UDim2.new(), Color3.new())


local function GetDictionaryLength(Dictionary: table)
    local Length = 0
    for _ in pairs(Dictionary) do
        Length += 1
    end
    return Length
end


local function UpdateSelectedTabLines(Tab: Tab)
    if not Tab then return end

    if (Tab.Button.AbsolutePosition.X > Tab.self.AbsolutePosition.X) then
        SelectedTabLines.Left.Visible = true
    else
        SelectedTabLines.Left.Visible = false
    end

    if (Tab.Button.AbsolutePosition.X + Tab.Button.AbsoluteSize.X < Tab.self.AbsolutePosition.X + Tab.self.AbsoluteSize.X) then
        SelectedTabLines.Right.Visible = true
    else
        SelectedTabLines.Right.Visible = false
    end

    --SelectedTabLines.Top.Parent = Tab.Button
    SelectedTabLines.Left.Parent = Tab.Button
    SelectedTabLines.Right.Parent = Tab.Button

    local FRAME_POSITION = Tab.self.AbsolutePosition
    local BUTTON_POSITION = Tab.Button.AbsolutePosition
    local BUTTON_SIZE = Tab.Button.AbsoluteSize
    local LENGTH = BUTTON_POSITION.X - FRAME_POSITION.X
    local OFFSET = (BUTTON_POSITION.X + BUTTON_SIZE.X) - FRAME_POSITION.X

    SelectedTabLines.Bottom.Size = UDim2.new(0, LENGTH + 1, 0, 1)
    SelectedTabLines.Bottom2.Size = UDim2.new(1, -OFFSET, 0, 1)
    SelectedTabLines.Bottom2.Position = UDim2.new(0, OFFSET, 1, 0)
end


local function UpdateTabs()
    for _, Tab in pairs(Tabs) do
        Tab.Button.Size = UDim2.new(1 / GetDictionaryLength(Tabs), 0, 1, 0)
        Tab.Button.Position = UDim2.new((1 / GetDictionaryLength(Tabs)) * (Tab.Index - 1), 0, 0, 0)
    end
    UpdateSelectedTabLines(SelectedTab)
end


local function GetTab(Tab_Name: string): Tab
    assert(Tab_Name, "NO TAB_NAME GIVEN")
    return Tabs[Tab_Name]
end

local function ChangeTab(Tab_Name: string)
    assert(Tabs[Tab_Name], "Tab \"" .. tostring(Tab_Name) .. "\" does not exist!")
    for _, Tab in pairs(Tabs) do
        Tab.self.Visible = false
        Tab.Button.BackgroundColor3 = Menu.ItemColor
        Tab.Button.TextColor3 = Color3.fromRGB(205, 205, 205)
    end
    local Tab = GetTab(Tab_Name)
    Tab.self.Visible = true
    Tab.Button.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    Tab.Button.TextColor3 = Color3.new(1, 1, 1)

    SelectedTab = Tab
    UpdateSelected()
    UpdateSelectedTabLines(Tab)
end


local function GetContainer(Tab_Name: string, Container_Name: string): Container
    assert(Tab_Name, "NO TAB_NAME GIVEN")
    assert(Container_Name, "NO CONTAINER NAME GIVEN")
    return GetTab(Tab_Name)[Container_Name]
end


local function CheckItemIndex(Item_Index: number, Method: string)
    assert(typeof(Item_Index) == "number", "invalid argument #1 to '" .. Method .. "' (number expected, got " .. typeof(Item_Index) .. ")")
    assert(Item_Index <= #Items and Item_Index > 0, "invalid argument #1 to '" .. Method .. "' (index out of range")
end


function Menu:GetItem(Index: number): Item
    CheckItemIndex(Index, "GetItem")
    return Items[Index]
end


function Menu:FindItem(Tab_Name: string, Container_Name: string, Class_Name: string, Name: string): Item
    local Result
    for Index, Item in ipairs(Items) do
        if Item.Tab == Tab_Name and Item.Container == Container_Name then
            if Item.Name == Name and (Item.Class == Class_Name) then
                Result = Index
                break
            end
        end
    end

    if Result then
        return Menu:GetItem(Result)
    else
        return error("Item " .. tostring(Name) .. " was not found")
    end
end


function Menu:SetTitle(Name: string)
    Title_Label.Text = tostring(Name)
end


function Menu:SetIcon(Icon: string)
    if typeof(Icon) == "string" or typeof(Icon) == "number" then
        Title_Label.Position = UDim2.fromOffset(20, 0)
        Title_Label.Size = UDim2.new(1, -40, 0, 15)
        Icon_Image.Image = "rbxassetid://" .. string.gsub(tostring(Icon), "rbxassetid://", "")
        Icon_Image.Visible = true
    else
        Title_Label.Position = UDim2.fromOffset(5, 0)
        Title_Label.Size = UDim2.new(1, -10, 0, 15)
        Icon_Image.Image = ""
        Icon_Image.Visible = false
    end
end


function Menu:SetSize(Size: Vector2)
    local Size = typeof(Size) == "Vector2" and Size or typeof(Size) == "UDim2" and Vector2.new(Size.X, Size.Y) or Menu.MinSize
    local X = Size.X
    local Y = Size.Y

    if (X > Menu.MinSize.X and X < Menu.MaxSize.X) then
        X = math.clamp(X, Menu.MinSize.X, Menu.MaxSize.X)
    end
    if (Y > Menu.MinSize.Y and Y < Menu.MaxSize.Y) then
        Y = math.clamp(Y, Menu.MinSize.Y, Menu.MaxSize.Y)
    end

    Menu_Frame.Size = UDim2.fromOffset(X, Y)
    UpdateTabs()
end


function Menu:SetVisible(Visible: boolean)
    local IsVisible = typeof(Visible) == "boolean" and Visible
    Menu_Frame.Visible = IsVisible
    Menu.IsVisible = IsVisible
    if IsVisible == false then
        UpdateSelected()
    end
end


function Menu:SetTab(Tab_Name: string)
    ChangeTab(Tab_Name)
end


-- this function should be private
function Menu:SetToolTip(Enabled: boolean, Content: string, Item: Instance)
    ToolTip = {
        Enabled = Enabled,
        Content = Content,
        Item = Item
    }

    ToolTip_Label.Visible = Enabled
end


function Menu.Line(Parent: Instance, Size: UDim2, Position: UDim2): Line
    local Line = {self = CreateLine(Parent, Size, Position)}
    Line.Class = "Line"
    return Line
end


function Menu.Tab(Tab_Name: string): Tab
    assert(Tab_Name and typeof(Tab_Name) == "string", "TAB_NAME REQUIRED")
    if Tabs[Tab_Name] then return error("TAB_NAME '" .. tostring(Tab_Name) .. "' ALREADY EXISTS") end
    local Frame = Instance.new("Frame")
    local Button = Instance.new("TextButton")

    local Tab = {self = Frame, Button = Button}
    Tab.Class = "Tab"
    Tab.Index = GetDictionaryLength(Tabs) + 1


    local function CreateSide(Side: string)
        local Frame = Instance.new("ScrollingFrame")
        local ListLayout = Instance.new("UIListLayout")

        Frame.Name = Side
        Frame.Active = true
        Frame.BackgroundTransparency = 1
        Frame.BorderSizePixel = 0
        Frame.Size = Side == "Middle" and UDim2.new(1, -10, 1, -10) or UDim2.new(0.5, -10, 1, -10)
        Frame.Position = (Side == "Left" and UDim2.fromOffset(5, 5)) or (Side == "Right" and UDim2.new(0.5, 5, 0, 5) or Side == "Middle" and UDim2.fromOffset(5, 5))
        Frame.CanvasSize = UDim2.new(0, 0, 0, -10)
        Frame.ScrollBarThickness = 2
        Frame.ScrollBarImageColor3 = Menu.Accent
        Frame.Parent = Tab.self
        AddEventListener(Frame, function()
            Frame.ScrollBarImageColor3 = Menu.Accent
        end)
        Frame:GetPropertyChangedSignal("CanvasPosition"):Connect(UpdateSelected)

        ListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
        ListLayout.SortOrder = Enum.SortOrder.LayoutOrder
        ListLayout.Padding = UDim.new(0, 10)
        ListLayout.Parent = Frame
    end


    Button.Name = "Button"
    Button.BackgroundColor3 = Menu.ItemColor
    Button.BorderSizePixel = 0
    Button.Font = Enum.Font.SourceSans
    Button.Text = Tab_Name
    Button.TextColor3 = Color3.fromRGB(205, 205, 205)
    Button.TextSize = 14
    Button.Parent = TabIndex_Frame
    AddEventListener(Button, function()
        if Button.TextColor3 == Color3.fromRGB(205, 205, 205) then
            Button.BackgroundColor3 = Menu.ItemColor
        end
        Button.BackgroundColor3 = Menu.ItemColor
        Button.BorderColor3 = Menu.BorderColor
    end)
    Button.MouseButton1Click:Connect(function()
        ChangeTab(Tab_Name)
    end)
    
    Frame.Name = Tab_Name .. "Tab"
    Frame.BackgroundTransparency = 1
    Frame.Size = UDim2.new(1, 0, 1, 0)
    Frame.Visible = false
    Frame.Parent = Tabs_Frame

    CreateSide("Middle")
    CreateSide("Left")
    CreateSide("Right")

    Tabs[Tab_Name] = Tab

    ChangeTab(Tab_Name)
    UpdateTabs()
    return Tab
end


function Menu.Container(Tab_Name: string, Container_Name: string, Side: string): Container
    local Tab = GetTab(Tab_Name)
    assert(typeof(Tab_Name) == "string", "TAB_NAME REQUIRED")
    if Tab[Container_Name] then return error("CONTAINER_NAME '" .. tostring(Container_Name) .. "' ALREADY EXISTS") end
    local Side = Side or "Left"

    local Frame = Instance.new("Frame")
    local Label = CreateLabel(Frame, "Title", Container_Name, UDim2.fromOffset(206, 15),  UDim2.fromOffset(5, 0))
    local Line = CreateLine(Frame, UDim2.new(1, -10, 0, 1), UDim2.fromOffset(5, 15))

    local Container = {self = Frame, Height = 0}
    Container.Class = "Container"
    Container.Visible = true

    function Container:SetLabel(Name: string)
        Label.Text = tostring(Name)
    end

    function Container:SetVisible(Visible: boolean)
        if typeof(Visible) ~= "boolean" then return end
        if self.Visible == Visible then return end
        
        Frame.Visible = Visible
        self.Visible = Visible
        self:UpdateSize(Visible and 25 or -25, Frame)
    end

    function Container:UpdateSize(Height: float, Item: GuiObject)
        self.Height += Height
        Frame.Size += UDim2.fromOffset(0, Height)
        Tab.self[Side].CanvasSize += UDim2.fromOffset(0, Height)

        if Item then
            local ItemY = Item.AbsolutePosition.Y
            if math.sign(Height) == 1 then
                ItemY -= 1
            end

            for _, item in ipairs(Frame:GetChildren()) do
                if (item == Label or item == Line or item == Stroke or Item == item) then continue end -- exlude these
                local item_y = item.AbsolutePosition.Y
                if item_y > ItemY then
                    item.Position += UDim2.fromOffset(0, Height)
                end
            end
        end
    end

    function Container:GetHeight(): number
        return self.Height
    end


    Frame.Name = "Container"
    Frame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    Frame.BorderColor3 = Color3.new()
    Frame.BorderMode = Enum.BorderMode.Inset
    Frame.Size = UDim2.new(1, -6, 0, 0)
    Frame.Parent = Tab.self[Side]

    Container:UpdateSize(25)
    Tab.self[Side].CanvasSize += UDim2.fromOffset(0, 10)
    Tab[Container_Name] = Container
    return Container
end


function Menu.Label(Tab_Name: string, Container_Name: string, Name: string, ToolTip: string): Label
    local Container = GetContainer(Tab_Name, Container_Name)
    local GuiLabel = CreateLabel(Container.self, "Label", Name, nil, UDim2.fromOffset(20, Container:GetHeight()))

    GuiLabel.MouseEnter:Connect(function()
        if ToolTip then
            Menu:SetToolTip(true, ToolTip, GuiLabel)
        end
    end)
    GuiLabel.MouseLeave:Connect(function()
        if ToolTip then
            Menu:SetToolTip(false)
        end
    end)

    local Label = {self = Label}
    Label.Name = Name
    Label.Class = "Label"
    Label.Index = #Items + 1
    Label.Tab = Tab_Name
    Label.Container = Container_Name

    function Label:SetLabel(Name: string)
        GuiLabel.Text = tostring(Name)
    end

    function Label:SetVisible(Visible: boolean)
        if typeof(Visible) ~= "boolean" then return end
        if GuiLabel.Visible == Visible then return end
        
        GuiLabel.Visible = Visible
        Container:UpdateSize(Visible and 20 or -20, GuiLabel)
    end

    Container:UpdateSize(20)
    table.insert(Items, Label)
    return #Items
end


function Menu.Button(Tab_Name: string, Container_Name: string, Name: string, Callback: any, ToolTip: string): Button
    local Container = GetContainer(Tab_Name, Container_Name)
    local GuiButton = Instance.new("TextButton")

    local Button = {self = GuiButton}
    Button.Name = Name
    Button.Class = "Button"
    Button.Tab = Tab_Name
    Button.Container = Container_Name
    Button.Index = #Items + 1
    Button.Callback = typeof(Callback) == "function" and Callback or function() end

    
    function Button:SetLabel(Name: string)
        GuiButton.Text = tostring(Name)
    end

    function Button:SetVisible(Visible: boolean)
        if typeof(Visible) ~= "boolean" then return end
        if GuiButton.Visible == Visible then return end
        
        GuiButton.Visible = Visible
        Container:UpdateSize(Visible and 25 or -25, GuiButton)
    end


    GuiButton.Name = "Button"
    GuiButton.BackgroundColor3 = Menu.ItemColor
    GuiButton.BorderColor3 = Menu.BorderColor
    GuiButton.BorderMode = Enum.BorderMode.Inset
    GuiButton.Position = UDim2.fromOffset(20, Container:GetHeight())
    GuiButton.Size = UDim2.new(1, -50, 0, 20)
    GuiButton.Font = Enum.Font.SourceSansSemibold
    GuiButton.Text = Name
    GuiButton.TextColor3 = Color3.new(1, 1, 1)
    GuiButton.TextSize = 14
    GuiButton.TextTruncate = Enum.TextTruncate.AtEnd
    GuiButton.Parent = Container.self
    CreateStroke(GuiButton, Color3.new(), 1)
    AddEventListener(GuiButton, function()
        GuiButton.BackgroundColor3 = Menu.ItemColor
        GuiButton.BorderColor3 = Menu.BorderColor
    end)
    GuiButton.MouseButton1Click:Connect(function()
        Button.Callback()
    end)
    GuiButton.MouseEnter:Connect(function()
        if ToolTip then
            Menu:SetToolTip(true, ToolTip, GuiButton)
        end
    end)
    GuiButton.MouseLeave:Connect(function()
        Menu:SetToolTip(false)
    end)

    Container:UpdateSize(25)
    table.insert(Items, Button)
    return #Items
end


function Menu.TextBox(Tab_Name: string, Container_Name: string, Name: string, Value: string, Callback: any, ToolTip: string): TextBox
    local Container = GetContainer(Tab_Name, Container_Name)
    local Label = CreateLabel(Container.self, "TextBox", Name, nil, UDim2.fromOffset(20, Container:GetHeight()))
    local GuiTextBox = Instance.new("TextBox")

    local TextBox = {self = GuiTextBox}
    TextBox.Name = Name
    TextBox.Class = "TextBox"
    TextBox.Tab = Tab_Name
    TextBox.Container = Container_Name
    TextBox.Index = #Items + 1
    TextBox.Value = typeof(Value) == "string" and Value or ""
    TextBox.Callback = typeof(Callback) == "function" and Callback or function() end


    function TextBox:SetLabel(Name: string)
        Label.Text = tostring(Name)
    end

    function TextBox:SetVisible(Visible: boolean)
        if typeof(Visible) ~= "boolean" then return end
        if Label.Visible == Visible then return end
        
        Label.Visible = Visible
        Container:UpdateSize(Visible and 45 or -45, Label)
    end

    function TextBox:GetValue(): string
        return self.Value
    end

    function TextBox:SetValue(Value: string)
        self.Value = tostring(Value)
        GuiTextBox.Text = self.Value
    end


    GuiTextBox.Name = "TextBox"
    GuiTextBox.BackgroundColor3 = Menu.ItemColor
    GuiTextBox.BorderColor3 = Menu.BorderColor
    GuiTextBox.BorderMode = Enum.BorderMode.Inset
    GuiTextBox.Position = UDim2.fromOffset(0, 20)
    GuiTextBox.Size = UDim2.new(1, -50, 0, 20)
    GuiTextBox.Font = Enum.Font.SourceSansSemibold
    GuiTextBox.Text = TextBox.Value
    GuiTextBox.TextColor3 = Color3.new(1, 1, 1)
    GuiTextBox.TextSize = 14
    GuiTextBox.ClearTextOnFocus = false
    GuiTextBox.ClipsDescendants = true
    GuiTextBox.Parent = Label
    CreateStroke(GuiTextBox, Color3.new(), 1)
    AddEventListener(GuiTextBox, function()
        GuiTextBox.BackgroundColor3 = Menu.ItemColor
        GuiTextBox.BorderColor3 = Menu.BorderColor
    end)
    GuiTextBox.FocusLost:Connect(function()
        TextBox.Value = GuiTextBox.Text
        TextBox.Callback(GuiTextBox.Text)
    end)
    GuiTextBox.MouseEnter:Connect(function()
        if ToolTip then
            Menu:SetToolTip(true, ToolTip, GuiTextBox)
        end
    end)
    GuiTextBox.MouseLeave:Connect(function()
        if ToolTip then
            Menu:SetToolTip(false)
        end
    end)

    Container:UpdateSize(45)
    table.insert(Items, TextBox)
    return #Items
end


function Menu.CheckBox(Tab_Name: string, Container_Name: string, Name: string, Boolean: boolean, Callback: any, ToolTip: string): CheckBox
    local Container = GetContainer(Tab_Name, Container_Name)
    local Label = CreateLabel(Container.self, "CheckBox", Name, nil, UDim2.fromOffset(20, Container:GetHeight()))
    local Button = Instance.new("TextButton")
    
    local CheckBox = {self = Label}
    CheckBox.Name = Name
    CheckBox.Class = "CheckBox"
    CheckBox.Tab = Tab_Name
    CheckBox.Container = Container_Name
    CheckBox.Index = #Items + 1
    CheckBox.Value = typeof(Boolean) == "boolean" and Boolean or false
    CheckBox.Callback = typeof(Callback) == "function" and Callback or function() end


    function CheckBox:Update(Value: boolean)
        self.Value = typeof(Value) == "boolean" and Value
        Button.BackgroundColor3 = self.Value and Menu.Accent or Menu.ItemColor
    end

    function CheckBox:SetLabel(Name: string)
        Label.Text = tostring(Name)
    end

    function CheckBox:SetVisible(Visible: boolean)
        if typeof(Visible) ~= "boolean" then return end
        if Label.Visible == Visible then return end
        
        Label.Visible = Visible
        Container:UpdateSize(Visible and 20 or -20, Label)
    end

    function CheckBox:GetValue(): boolean
        return self.Value
    end

    function CheckBox:SetValue(Value: boolean)
        self:Update(Value)
    end


    Label.MouseEnter:Connect(function()
        if ToolTip then
            Menu:SetToolTip(true, ToolTip, Label)
        end
    end)
    Label.MouseLeave:Connect(function()
        if ToolTip then
            Menu:SetToolTip(false)
        end
    end)

    Button.BackgroundColor3 = Menu.ItemColor
    Button.BorderColor3 = Color3.new()
    Button.Position = UDim2.fromOffset(-14, 4)
    Button.Size = UDim2.fromOffset(8, 8)
    Button.Text = ""
    Button.Parent = Label
    AddEventListener(Button, function()
        Button.BackgroundColor3 = CheckBox.Value and Menu.Accent or Menu.ItemColor
    end)
    Button.MouseButton1Click:Connect(function()
        CheckBox:Update(not CheckBox.Value)
        CheckBox.Callback(CheckBox.Value)
    end)

    CheckBox:Update(CheckBox.Value)
    Container:UpdateSize(20)
    table.insert(Items, CheckBox)
    return #Items
end


function Menu.Hotkey(Tab_Name: string, Container_Name: string, Name: string, Key:EnumItem, Callback: any, ToolTip: string): Hotkey
    local Container = GetContainer(Tab_Name, Container_Name)
    local Label = CreateLabel(Container.self, "Hotkey", Name, nil, UDim2.fromOffset(20, Container:GetHeight()))
    local Button = Instance.new("TextButton")
    local Selected_Hotkey = Instance.new("Frame")
    local HotkeyToggle = Instance.new("TextButton")
    local HotkeyHold = Instance.new("TextButton")

    local Hotkey = {self = Label}
    Hotkey.Name = Name
    Hotkey.Class = "Hotkey"
    Hotkey.Tab = Tab_Name
    Hotkey.Container = Container_Name
    Hotkey.Index = #Items + 1
    Hotkey.Key = typeof(Key) == "EnumItem" and Key or nil
    Hotkey.Callback = typeof(Callback) == "function" and Callback or function() end
    Hotkey.Editing = false
    Hotkey.Mode = "Toggle"


    function Hotkey:Update(Input: EnumItem, Mode: string)
        Button.Text = Input and string.format("[%s]", Input.Name) or "[None]"

        self.Key = Input
        self.Mode = Mode or "Toggle"
        self.Editing = false
    end

    function Hotkey:SetLabel(Name: string)
        Label.Text = tostring(Name)
    end

    function Hotkey:SetVisible(Visible: boolean)
        if typeof(Visible) ~= "boolean" then return end
        if Label.Visible == Visible then return end
        
        Label.Visible = Visible
        Container:UpdateSize(Visible and 20 or -20, Label)
    end

    function Hotkey:GetValue(): EnumItem--, string
        return self.Key, self.Mode
    end

    function Hotkey:SetValue(Key: EnumItem, Mode: string)
        self:Update(Key, Mode)
    end


    Label.MouseEnter:Connect(function()
        if ToolTip then
            Menu:SetToolTip(true, ToolTip, Label)
        end
    end)
    Label.MouseLeave:Connect(function()
        if ToolTip then
            Menu:SetToolTip(false)
        end
    end)

    Button.Name = "Hotkey"
    Button.BackgroundTransparency = 1
    Button.Position = UDim2.new(1, -100, 0, 4)
    Button.Size = UDim2.fromOffset(75, 8)
    Button.Font = Enum.Font.SourceSans
    Button.Text = Key and "[" .. Key.Name .. "]" or "[None]"
    Button.TextColor3 = Color3.new(1, 1, 1)
    Button.TextSize = 12
    Button.TextXAlignment = Enum.TextXAlignment.Right
    Button.Parent = Label

    Selected_Hotkey.Name = "Selected_Hotkey"
    Selected_Hotkey.Visible = false
    Selected_Hotkey.BackgroundColor3 = Menu.ItemColor
    Selected_Hotkey.BorderColor3 = Menu.BorderColor
    Selected_Hotkey.Position = UDim2.fromOffset(200, 100)
    Selected_Hotkey.Size = UDim2.fromOffset(100, 30)
    Selected_Hotkey.Parent = nil
    CreateStroke(Selected_Hotkey, Color3.new(), 1)
    AddEventListener(Selected_Hotkey, function()
        Selected_Hotkey.BackgroundColor3 = Menu.ItemColor
        Selected_Hotkey.BorderColor3 = Menu.BorderColor
    end)

    HotkeyToggle.Parent = Selected_Hotkey
    HotkeyToggle.BackgroundColor3 = Menu.ItemColor
    HotkeyToggle.BorderColor3 = Color3.new()
    HotkeyToggle.BorderSizePixel = 0
    HotkeyToggle.Position = UDim2.new()
    HotkeyToggle.Size = UDim2.new(1, 0, 0, 13)
    HotkeyToggle.Font = Enum.Font.SourceSans
    HotkeyToggle.Text = "Toggle"
    HotkeyToggle.TextColor3 = Menu.Accent
    HotkeyToggle.TextSize = 14
    AddEventListener(HotkeyToggle, function()
        HotkeyToggle.BackgroundColor3 = Menu.ItemColor
        if Hotkey.Mode == "Toggle" then
            HotkeyToggle.TextColor3 = Menu.Accent
        end
    end)
    HotkeyToggle.MouseButton1Click:Connect(function()
        Hotkey:Update(Hotkey.Key, "Toggle")
        HotkeyToggle.TextColor3 = Menu.Accent
        HotkeyHold.TextColor3 = Color3.new(1, 1, 1)
        UpdateSelected()
        Hotkey.Callback(Hotkey.Key, Hotkey.Mode)
    end)

    HotkeyHold.Parent = Selected_Hotkey
    HotkeyHold.BackgroundColor3 = Menu.ItemColor
    HotkeyHold.BorderColor3 = Color3.new()
    HotkeyHold.BorderSizePixel = 0
    HotkeyHold.Position = UDim2.new(0, 0, 0, 15)
    HotkeyHold.Size = UDim2.new(1, 0, 0, 13)
    HotkeyHold.Font = Enum.Font.SourceSans
    HotkeyHold.Text = "Hold"
    HotkeyHold.TextColor3 = Color3.new(1, 1, 1)
    HotkeyHold.TextSize = 14
    AddEventListener(HotkeyHold, function()
        HotkeyHold.BackgroundColor3 = Menu.ItemColor
        if Hotkey.Mode == "Hold" then
            HotkeyHold.TextColor3 = Menu.Accent
        end
    end)
    HotkeyHold.MouseButton1Click:Connect(function()
        Hotkey:Update(Hotkey.Key, "Hold")
        HotkeyHold.TextColor3 = Menu.Accent
        HotkeyToggle.TextColor3 = Color3.new(1, 1, 1)
        UpdateSelected()
        Hotkey.Callback(Hotkey.Key, Hotkey.Mode)
    end)

    Button.MouseButton1Click:Connect(function()
        Button.Text = "..."
        Hotkey.Editing = true
        if UserInput:IsKeyDown(HotkeyRemoveKey) and Key ~= HotkeyRemoveKey then
            Hotkey:Update()
            Hotkey.Callback(nil, Hotkey.Mode)
        end
    end)
    Button.MouseButton2Click:Connect(function()
        UpdateSelected(Selected_Hotkey, Button, UDim2.fromOffset(100, 0))
    end)

    UserInput.InputBegan:Connect(function(Input)
        if Hotkey.Editing then
            local Key = Input.KeyCode
            if Key == Enum.KeyCode.Unknown then
                local InputType = Input.UserInputType
                Hotkey:Update(InputType)
                Hotkey.Callback(InputType, Hotkey.Mode)
            else
                Hotkey:Update(Key)
                Hotkey.Callback(Key, Hotkey.Mode)
            end
        end
    end)

    Container:UpdateSize(20)
    table.insert(Items, Hotkey)
    return #Items
end


function Menu.Slider(Tab_Name: string, Container_Name: string, Name: string, Min: number, Max: number, Value: number, Unit: string, Scale: number, Callback: any, ToolTip: string): Slider
    local Container = GetContainer(Tab_Name, Container_Name)
    local Label = CreateLabel(Container.self, "Slider", Name, UDim2.new(1, -10, 0, 15), UDim2.fromOffset(20, Container:GetHeight()))
    local Button = Instance.new("TextButton")
    local ValueBar = Instance.new("TextLabel")
    local ValueBox = Instance.new("TextBox")
    local ValueLabel = Instance.new("TextLabel")

    local Slider = {}
    Slider.Name = Name
    Slider.Class = "Slider"
    Slider.Tab = Tab_Name
    Slider.Container = Container_Name
    Slider.Index = #Items + 1
    Slider.Min = typeof(Min) == "number" and math.clamp(Min, Min, Max) or 0
    Slider.Max = typeof(Max) == "number" and Max or 100
    Slider.Value = typeof(Value) == "number" and Value or 100
    Slider.Unit = typeof(Unit) == "string" and Unit or ""
    Slider.Scale = typeof(Scale) == "number" and Scale or 0
    Slider.Callback = typeof(Callback) == "function" and Callback or function() end


    local function UpdateSlider(Percentage: number)
        local Percentage = typeof(Percentage == "number") and math.clamp(Percentage, 0, 1) or 0
        local Value = Slider.Min + ((Slider.Max - Slider.Min) * Percentage)
        local Scale = (10 ^ Slider.Scale)
        Slider.Value = math.round(Value * Scale) / Scale

        ValueBar.Size = UDim2.new(Percentage, 0, 0, 5)
        ValueBox.Text = "[" .. Slider.Value .. "]"
        ValueLabel.Text = Slider.Value .. Slider.Unit
    end


    function Slider:Update(Percentage: number)
        UpdateSlider(Percentage)
    end

    function Slider:SetLabel(Name: string)
        Label.Text = tostring(Name)
    end

    function Slider:SetVisible(Visible: boolean)
        if typeof(Visible) ~= "boolean" then return end
        if Label.Visible == Visible then return end
        
        Label.Visible = Visible
        Container:UpdateSize(Visible and 30 or -30, Label)
    end

    function Slider:GetValue(): number
        return self.Value
    end

    function Slider:SetValue(Value: number)
        self.Value = typeof(Value) == "number" and math.clamp(Value, self.Min, self.Max) or self.Min
        local Percentage = (self.Value - self.Min) / (self.Max - self.Min)
        self:Update(Percentage)
    end

    Slider.self = Label

    Label.MouseEnter:Connect(function()
        if ToolTip then
            Menu:SetToolTip(true, ToolTip, Label)
        end
    end)
    Label.MouseLeave:Connect(function()
        Menu:SetToolTip(false)
    end)

    Button.Name = "Slider"
    Button.BackgroundColor3 = Color3.fromRGB(15, 15, 15)
    Button.BorderColor3 = Color3.new()
    Button.Position = UDim2.fromOffset(0, 20)
    Button.Size = UDim2.new(1, -40, 0, 5)
    Button.Text = ""
    Button.AutoButtonColor = false
    Button.Parent = Label

    ValueBar.Name = "ValueBar"
    ValueBar.BackgroundColor3 = Menu.Accent
    ValueBar.BorderSizePixel = 0
    ValueBar.Size = UDim2.fromScale(1, 1)
    ValueBar.Text = ""
    ValueBar.Parent = Button
    AddEventListener(ValueBar, function()
        ValueBar.BackgroundColor3 = Menu.Accent
    end)
    
    ValueBox.Name = "ValueBox"
    ValueBox.BackgroundTransparency = 1
    ValueBox.Position = UDim2.new(1, -65, 0, 5)
    ValueBox.Size = UDim2.fromOffset(50, 10)
    ValueBox.Font = Enum.Font.SourceSans
    ValueBox.Text = ""
    ValueBox.TextColor3 = Color3.new(1, 1, 1)
    ValueBox.TextSize = 12
    ValueBox.TextXAlignment = Enum.TextXAlignment.Right
    ValueBox.ClipsDescendants = true
    ValueBox.Parent = Label
    ValueBox.FocusLost:Connect(function()
        Slider.Value = tonumber(ValueBox.Text) or 0
        local Percentage = (Slider.Value - Slider.Min) / (Slider.Max - Slider.Min)
        Slider:Update(Percentage)
        Slider.Callback(Slider.Value)
    end)

    ValueLabel.Name = "ValueLabel"
    ValueLabel.BackgroundTransparency = 1
    ValueLabel.Position = UDim2.new(1, 0, 0, 2)
    ValueLabel.Size = UDim2.new(0, 0, 1, 0)
    ValueLabel.Font = Enum.Font.SourceSansBold
    ValueLabel.Text = ""
    ValueLabel.TextColor3 = Color3.new(1, 1, 1)
    ValueLabel.TextSize = 14
    ValueLabel.Parent = ValueBar

    Button.InputBegan:Connect(function(Input: InputObject, Process: boolean)
        if (not Dragging.Gui and not Dragging.True) and (Input.UserInputType == Enum.UserInputType.MouseButton1) then
            Dragging = {Gui = Button, True = true}
            local InputPosition = Vector2.new(Input.Position.X, Input.Position.Y)
            local Percentage = (InputPosition - Button.AbsolutePosition) / Button.AbsoluteSize
            Slider:Update(Percentage.X)
            Slider.Callback(Slider.Value)
        end
    end)

    UserInput.InputChanged:Connect(function(Input: InputObject, Process: boolean)
        if Dragging.Gui ~= Button then return end
        if not (UserInput:IsMouseButtonPressed(Enum.UserInputType.MouseButton1)) then
            Dragging = {Gui = nil, True = false}
            return
        end
        if (Input.UserInputType == Enum.UserInputType.MouseMovement) then
            local InputPosition = Vector2.new(Input.Position.X, Input.Position.Y)
            local Percentage = (InputPosition - Button.AbsolutePosition) / Button.AbsoluteSize
            Slider:Update(Percentage.X)
            Slider.Callback(Slider.Value)
        end
    end)


    Slider:SetValue(Slider.Value)
    Container:UpdateSize(30)
    table.insert(Items, Slider)
    return #Items
end


function Menu.ColorPicker(Tab_Name: string, Container_Name: string, Name: string, Color: Color3, Alpha: number, Callback: any, ToolTip: string): ColorPicker
    local Container = GetContainer(Tab_Name, Container_Name)
    local Label = CreateLabel(Container.self, "ColorPicker", Name, UDim2.new(1, -10, 0, 15), UDim2.fromOffset(20, Container:GetHeight()))
    local Button = Instance.new("TextButton")
    local Selected_ColorPicker = Instance.new("Frame")
    local HexBox = Instance.new("TextBox")
    local Saturation = Instance.new("ImageButton")
    local Alpha = Instance.new("ImageButton")
    local Hue = Instance.new("ImageButton")
    local SaturationCursor = Instance.new("Frame")
    local AlphaCursor = Instance.new("Frame")
    local HueCursor = Instance.new("Frame")
    local CopyButton = Instance.new("TextButton") -- rbxassetid://9090721920
    local PasteButton = Instance.new("TextButton") -- rbxassetid://9090721063
    local AlphaColorGradient = Instance.new("UIGradient")

    local ColorPicker = {self = Label}
    ColorPicker.Name = Name
    ColorPicker.Tab = Tab_Name
    ColorPicker.Class = "ColorPicker"
    ColorPicker.Container = Container_Name
    ColorPicker.Index = #Items + 1
    ColorPicker.Color = typeof(Color) == "Color3" and Color or Color3.new(1, 1, 1)
    ColorPicker.Saturation = {0, 0} -- no i'm not going to use ColorPicker.Value that would confuse people with ColorPicker.Color
    ColorPicker.Alpha = typeof(Alpha) == "number" and Alpha or 0
    ColorPicker.Hue = 0
    ColorPicker.Callback = typeof(Callback) == "function" and Callback or function() end


    local function UpdateColor()
        ColorPicker.Color = Color3.fromHSV(ColorPicker.Hue, ColorPicker.Saturation[1], ColorPicker.Saturation[2])

        HexBox.Text = "#" .. string.upper(ColorPicker.Color:ToHex()) .. string.upper(string.format("%X", ColorPicker.Alpha * 255))
        Button.BackgroundColor3 = ColorPicker.Color
        Saturation.BackgroundColor3 = ColorPicker.Color
        AlphaColorGradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0, Color3.new(1, 1, 1)), ColorSequenceKeypoint.new(1, ColorPicker.Color)}

        SaturationCursor.Position = UDim2.fromScale(math.clamp(ColorPicker.Saturation[1], 0, 0.95), math.clamp(1 - ColorPicker.Saturation[2], 0, 0.95))
        AlphaCursor.Position = UDim2.fromScale(0, math.clamp(ColorPicker.Alpha, 0, 0.98))
        HueCursor.Position = UDim2.fromScale(0, math.clamp(ColorPicker.Hue, 0, 0.98))

        ColorPicker.Callback(ColorPicker.Color, ColorPicker.Alpha)
    end


    function ColorPicker:Update()
        UpdateColor()
    end

    function ColorPicker:SetLabel(Name: string)
        Label.Text = tostring(Name)
    end

    function ColorPicker:SetVisible(Visible: boolean)
        if typeof(Visible) ~= "boolean" then return end
        if Label.Visible == Visible then return end
        
        Label.Visible = Visible
        Container:UpdateSize(Visible and 20 or -20, Label)
    end

    function ColorPicker:SetValue(Color: Color3, Alpha: number)
        self.Color, self.Alpha = typeof(Color) == "Color3" and Color or Color3.new(), typeof(Alpha) == "number" and Alpha or 0
        self.Hue, self.Saturation[1], self.Saturation[2] = self.Color:ToHSV()
        self:Update()
    end

    function ColorPicker:GetValue(): Color3--, number
        return self.Color, self.Alpha
    end


    Label.MouseEnter:Connect(function()
        if ToolTip then
            Menu:SetToolTip(true, ToolTip, Label)
        end
    end)
    Label.MouseLeave:Connect(function()
        if ToolTip then
            Menu:SetToolTip(false)
        end
    end)

    Button.Name = "ColorPicker"
    Button.BackgroundColor3 = ColorPicker.Color
    Button.BorderColor3 = Color3.new()
    Button.Position = UDim2.new(1, -35, 0, 4)
    Button.Size = UDim2.fromOffset(20, 8)
    Button.Font = Enum.Font.SourceSans
    Button.Text = ""
    Button.TextColor3 = Color3.new(1, 1, 1)
    Button.TextSize = 12
    Button.Parent = Label
    Button.MouseButton1Click:Connect(function()
        UpdateSelected(Selected_ColorPicker, Button, UDim2.fromOffset(20, 20))
    end)

    Selected_ColorPicker.Name = "Selected_ColorPicker"
    Selected_ColorPicker.Visible = false
    Selected_ColorPicker.BackgroundColor3 = Menu.ItemColor
    Selected_ColorPicker.BorderColor3 = Menu.BorderColor
    Selected_ColorPicker.BorderMode = Enum.BorderMode.Inset
    Selected_ColorPicker.Position = UDim2.new(0, 200, 0, 170)
    Selected_ColorPicker.Size = UDim2.new(0, 190, 0, 180)
    Selected_ColorPicker.Parent = nil
    CreateStroke(Selected_ColorPicker, Color3.new(), 1)
    AddEventListener(Selected_ColorPicker, function()
        Selected_ColorPicker.BackgroundColor3 = Menu.ItemColor
        Selected_ColorPicker.BorderColor3 = Menu.BorderColor
    end)

    HexBox.Name = "Hex"
    HexBox.BackgroundColor3 = Menu.ItemColor
    HexBox.BorderColor3 = Menu.BorderColor
    HexBox.BorderMode = Enum.BorderMode.Inset
    HexBox.Size = UDim2.new(1, -10, 0, 20)
    HexBox.Position = UDim2.fromOffset(5, 150)
    HexBox.Text = "#" .. string.upper(ColorPicker.Color:ToHex())
    HexBox.Font = Enum.Font.SourceSansSemibold
    HexBox.TextSize = 14
    HexBox.TextColor3 = Color3.new(1, 1, 1)
    HexBox.ClearTextOnFocus = false
    HexBox.ClipsDescendants = true
    HexBox.Parent = Selected_ColorPicker
    CreateStroke(HexBox, Color3.new(), 1)
    HexBox.FocusLost:Connect(function()
        pcall(function()
            local Color, Alpha = string.sub(HexBox.Text, 1, 7), string.sub(HexBox.Text, 8, #HexBox.Text)
            ColorPicker.Color = Color3.fromHex(Color)
            ColorPicker.Alpha = tonumber(Alpha, 16) / 255
            ColorPicker.Hue, ColorPicker.Saturation[1], ColorPicker.Saturation[2] = ColorPicker.Color:ToHSV()
            ColorPicker:Update()
        end)
    end)
    AddEventListener(HexBox, function()
        HexBox.BackgroundColor3 = Menu.ItemColor
        HexBox.BorderColor3 = Menu.BorderColor
    end)

    Saturation.Name = "Saturation"
    Saturation.BackgroundColor3 = ColorPicker.Color
    Saturation.BorderColor3 = Menu.BorderColor
    Saturation.Position = UDim2.new(0, 4, 0, 4)
    Saturation.Size = UDim2.new(0, 150, 0, 140)
    Saturation.Image = "rbxassetid://8180999986"
    Saturation.ImageColor3 = Color3.new()
    Saturation.AutoButtonColor = false
    Saturation.Parent = Selected_ColorPicker
    CreateStroke(Saturation, Color3.new(), 1)
    AddEventListener(Saturation, function()
        Saturation.BorderColor3 = Menu.BorderColor
    end)
    
    Alpha.Name = "Alpha"
    Alpha.BorderColor3 = Menu.BorderColor
    Alpha.Position = UDim2.new(0, 175, 0, 4)
    Alpha.Size = UDim2.new(0, 10, 0, 140)
    Alpha.Image = "rbxassetid://8181003956"--"rbxassetid://8181003956"
    Alpha.ScaleType = Enum.ScaleType.Crop
    Alpha.AutoButtonColor = false
    Alpha.Parent = Selected_ColorPicker
    CreateStroke(Alpha, Color3.new(), 1)
    AddEventListener(Alpha, function()
        Alpha.BorderColor3 = Menu.BorderColor
    end)

    Hue.Name = "Hue"
    Hue.BackgroundColor3 = Color3.new(1, 1, 1)
    Hue.BorderColor3 = Menu.BorderColor
    Hue.Position = UDim2.new(0, 160, 0, 4)
    Hue.Size = UDim2.new(0, 10, 0, 140)
    Hue.Image = "rbxassetid://8180989234"
    Hue.ScaleType = Enum.ScaleType.Crop
    Hue.AutoButtonColor = false
    Hue.Parent = Selected_ColorPicker
    CreateStroke(Hue, Color3.new(), 1)
    AddEventListener(Hue, function()
        Hue.BorderColor3 = Menu.BorderColor
    end)

    SaturationCursor.Name = "Cursor"
    SaturationCursor.BackgroundColor3 = Color3.new(1, 1, 1)
    SaturationCursor.BorderColor3 = Color3.new()
    SaturationCursor.Size = UDim2.fromOffset(5, 5)
    SaturationCursor.Parent = Saturation

    AlphaCursor.Name = "Cursor"
    AlphaCursor.BackgroundColor3 = Color3.new(1, 1, 1)
    AlphaCursor.BorderColor3 = Color3.new()
    AlphaCursor.Size = UDim2.new(1, 0, 0, 2)
    AlphaCursor.Parent = Alpha

    HueCursor.Name = "Cursor"
    HueCursor.BackgroundColor3 = Color3.new(1, 1, 1)
    HueCursor.BorderColor3 = Color3.new()
    HueCursor.Size = UDim2.new(1, 0, 0, 2)
    HueCursor.Parent = Hue

    AlphaColorGradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0, Color3.new(1, 1, 1)), ColorSequenceKeypoint.new(1, ColorPicker.Color)}
    AlphaColorGradient.Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0, 0.20), NumberSequenceKeypoint.new(1, 0.2)}
    AlphaColorGradient.Offset = Vector2.new(0, -0.1)
    AlphaColorGradient.Rotation = -90
    AlphaColorGradient.Parent = Alpha

    local function UpdateSaturation(PercentageX: number, PercentageY: number)
        local PercentageX = typeof(PercentageX == "number") and math.clamp(PercentageX, 0, 1) or 0
        local PercentageY = typeof(PercentageY == "number") and math.clamp(PercentageY, 0, 1) or 0
        ColorPicker.Saturation[1] = PercentageX
        ColorPicker.Saturation[2] = 1 - PercentageY
        ColorPicker:Update()
    end

    local function UpdateAlpha(Percentage: number)
        local Percentage = typeof(Percentage == "number") and math.clamp(Percentage, 0, 1) or 0
        ColorPicker.Alpha = Percentage
        ColorPicker:Update()
    end

    local function UpdateHue(Percentage: number)
        local Percentage = typeof(Percentage == "number") and math.clamp(Percentage, 0, 1) or 0
        ColorPicker.Hue = Percentage
        ColorPicker:Update()
    end

    Saturation.InputBegan:Connect(function(Input: InputObject, Process: boolean)
        if (not Dragging.Gui and not Dragging.True) and (Input.UserInputType == Enum.UserInputType.MouseButton1) then
            Dragging = {Gui = Saturation, True = true}
            local InputPosition = Vector2.new(Input.Position.X, Input.Position.Y)
            local Percentage = (InputPosition - Saturation.AbsolutePosition) / Saturation.AbsoluteSize
            UpdateSaturation(Percentage.X, Percentage.Y)
        end
    end)

    Alpha.InputBegan:Connect(function(Input: InputObject, Process: boolean)
        if (not Dragging.Gui and not Dragging.True) and (Input.UserInputType == Enum.UserInputType.MouseButton1) then
            Dragging = {Gui = Alpha, True = true}
            local InputPosition = Vector2.new(Input.Position.X, Input.Position.Y)
            local Percentage = (InputPosition - Alpha.AbsolutePosition) / Alpha.AbsoluteSize
            UpdateAlpha(Percentage.Y)
        end
    end)

    Hue.InputBegan:Connect(function(Input: InputObject, Process: boolean)
        if (not Dragging.Gui and not Dragging.True) and (Input.UserInputType == Enum.UserInputType.MouseButton1) then
            Dragging = {Gui = Hue, True = true}
            local InputPosition = Vector2.new(Input.Position.X, Input.Position.Y)
            local Percentage = (InputPosition - Hue.AbsolutePosition) / Hue.AbsoluteSize
            UpdateHue(Percentage.Y)
        end
    end)

    UserInput.InputChanged:Connect(function(Input: InputObject, Process: boolean)
        if (Dragging.Gui ~= Saturation and Dragging.Gui ~= Alpha and Dragging.Gui ~= Hue) then return end
        if not (UserInput:IsMouseButtonPressed(Enum.UserInputType.MouseButton1)) then
            Dragging = {Gui = nil, True = false}
            return
        end

        local InputPosition = Vector2.new(Input.Position.X, Input.Position.Y)
        if (Input.UserInputType == Enum.UserInputType.MouseMovement) then
            if Dragging.Gui == Saturation then
                local Percentage = (InputPosition - Saturation.AbsolutePosition) / Saturation.AbsoluteSize
                UpdateSaturation(Percentage.X, Percentage.Y)
            end
            if Dragging.Gui == Alpha then
                local Percentage = (InputPosition - Alpha.AbsolutePosition) / Alpha.AbsoluteSize
                UpdateAlpha(Percentage.Y)
            end
            if Dragging.Gui == Hue then
                local Percentage = (InputPosition - Hue.AbsolutePosition) / Hue.AbsoluteSize
                UpdateHue(Percentage.Y)
            end
        end
    end)
    
    
    ColorPicker.Hue, ColorPicker.Saturation[1], ColorPicker.Saturation[2] = ColorPicker.Color:ToHSV()
    ColorPicker:Update()
    Container:UpdateSize(20)
    table.insert(Items, ColorPicker)
    return #Items
end


function Menu.ComboBox(Tab_Name: string, Container_Name: string, Name: string, Value: string, Value_Items: table, Callback: any, ToolTip: string): ComboBox
    local Container = GetContainer(Tab_Name, Container_Name)
    local Label = CreateLabel(Container.self, "ComboBox", Name, UDim2.new(1, -10, 0, 15), UDim2.fromOffset(20, Container:GetHeight()))
    local Button = Instance.new("TextButton")
    local Symbol = Instance.new("TextLabel")
    local List = Instance.new("ScrollingFrame")
    local ListLayout = Instance.new("UIListLayout")

    local ComboBox = {}
    ComboBox.Name = Name
    ComboBox.Class = "ComboBox"
    ComboBox.Tab = Tab_Name
    ComboBox.Container = Container_Name
    ComboBox.Index = #Items + 1
    ComboBox.Callback = typeof(Callback) == "function" and Callback or function() end
    ComboBox.Value = typeof(Value) == "string" and Value or ""
    ComboBox.Items = typeof(Value_Items) == "table" and Value_Items or {}

    local function UpdateValue(Value: string)
        ComboBox.Value = tostring(Value)
        Button.Text = ComboBox.Value or "[...]"
    end

    local ItemObjects = {}
    local function AddItem(Name: string)
        local Button = Instance.new("TextButton")
        Button.BackgroundColor3 = Menu.ItemColor
        Button.BorderColor3 = Color3.new()
        Button.BorderSizePixel = 0
        Button.Size = UDim2.new(1, 0, 0, 15)
        Button.Font = Enum.Font.SourceSans
        Button.Text = tostring(Name)
        Button.TextColor3 = ComboBox.Value == Button.Text and Menu.Accent or Color3.new(1, 1, 1)
        Button.TextSize = 14
        Button.TextTruncate = Enum.TextTruncate.AtEnd
        Button.Parent = List
        Button.MouseButton1Click:Connect(function()
            for _, v in ipairs(List:GetChildren()) do
                if v:IsA("GuiButton") then
                    if v == Button then continue end
                    v.TextColor3 = Color3.new(1, 1, 1)
                end
            end
            Button.TextColor3 = Menu.Accent
            UpdateValue(Button.Text)
            UpdateSelected()
            ComboBox.Callback(ComboBox.Value)
        end)
        AddEventListener(Button, function()
            Button.BackgroundColor3 = Menu.ItemColor
            if ComboBox.Value == Button.Text then
                Button.TextColor3 = Menu.Accent
            else
                Button.TextColor3 = Color3.new(1, 1, 1)
            end
        end)
        
        if #ComboBox.Items >= 6 then
            List.CanvasSize += UDim2.fromOffset(0, 15)
        end
        table.insert(ItemObjects, Button)
    end


    function ComboBox:Update(Value: string, Items: any)
        UpdateValue(Value)
        if typeof(Items) == "table" then
            for _, Button in ipairs(ItemObjects) do
                Button:Destroy()
            end
            table.clear(ItemObjects)

            List.CanvasSize = UDim2.new()
            List.Size = UDim2.fromOffset(Button.AbsoluteSize.X, math.clamp(#self.Items * 15, 15, 90))
            for _, Item in ipairs(self.Items) do
                AddItem(tostring(Item))
            end
        else
            for _, Button in ipairs(ItemObjects) do
                Button.TextColor3 = self.Value == Button.Text and Menu.Accent or Color3.new(1, 1, 1)
            end
        end
    end

    function ComboBox:SetLabel(Name: string)
        Label.Text = tostring(Name)
    end

    function ComboBox:SetVisible(Visible: boolean)
        if typeof(Visible) ~= "boolean" then return end
        if Label.Visible == Visible then return end
        
        Label.Visible = Visible
        Container:UpdateSize(Visible and 40 or -40, Label)
    end

    function ComboBox:GetValue(): table
        return self.Value
    end

    function ComboBox:SetValue(Value: string, Items: any)
        if typeof(Items) == "table" then
            self.Items = Items
        end
        self:Update(Value, self.Items)
    end


    Label.MouseEnter:Connect(function()
        if ToolTip then
            Menu:SetToolTip(true, ToolTip, Label)
        end
    end)
    Label.MouseLeave:Connect(function()
        if ToolTip then
            Menu:SetToolTip(false)
        end
    end)

    Button.Name = "Button"
    Button.BackgroundColor3 = Menu.ItemColor
    Button.BorderColor3 = Color3.new()
    Button.Position = UDim2.new(0, 0, 0, 20)
    Button.Size = UDim2.new(1, -40, 0, 15)
    Button.Font = Enum.Font.SourceSans
    Button.Text = ComboBox.Value
    Button.TextColor3 = Color3.new(1, 1, 1)
    Button.TextSize = 14
    Button.TextTruncate = Enum.TextTruncate.AtEnd
    Button.Parent = Label
    Button.MouseButton1Click:Connect(function()
        UpdateSelected(List, Button, UDim2.fromOffset(0, 15))
        List.Size = UDim2.fromOffset(Button.AbsoluteSize.X, math.clamp(#ComboBox.Items * 15, 15, 90))
    end)
    AddEventListener(Button, function()
        Button.BackgroundColor3 = Menu.ItemColor
    end)

    Symbol.Name = "Symbol"
    Symbol.Parent = Button
    Symbol.BackgroundColor3 = Color3.new(1, 1, 1)
    Symbol.BackgroundTransparency = 1
    Symbol.Position = UDim2.new(1, -10, 0, 0)
    Symbol.Size = UDim2.new(0, 5, 1, 0)
    Symbol.Font = Enum.Font.SourceSans
    Symbol.Text = "-"
    Symbol.TextColor3 = Color3.new(1, 1, 1)
    Symbol.TextSize = 14

    List.Visible = false
    List.BackgroundColor3 = Menu.ItemColor
    List.BorderColor3 = Menu.BorderColor
    List.BorderMode = Enum.BorderMode.Inset
    List.Size = UDim2.fromOffset(Button.AbsoluteSize.X, math.clamp(#ComboBox.Items * 15, 15, 90))
    List.Position = UDim2.fromOffset(20, 30)
    List.CanvasSize = UDim2.new()
    List.ScrollBarThickness = 4
    List.ScrollBarImageColor3 = Menu.Accent
    List.Parent = Label
    CreateStroke(List, Color3.new(), 1)
    AddEventListener(List, function()
        List.BackgroundColor3 = Menu.ItemColor
        List.BorderColor3 = Menu.BorderColor
        List.ScrollBarImageColor3 = Menu.Accent
    end)

    ListLayout.Parent = List

    ComboBox:Update(ComboBox.Value, ComboBox.Items)
    Container:UpdateSize(40)
    table.insert(Items, ComboBox)
    return #Items
end


function Menu.MultiSelect(Tab_Name: string, Container_Name: string, Name: string, Value_Items: table, Callback: any, ToolTip: string): MultiSelect
    local Container = GetContainer(Tab_Name, Container_Name)
    local Label = CreateLabel(Container.self, "MultiSelect", Name, UDim2.new(1, -10, 0, 15), UDim2.fromOffset(20, Container:GetHeight()))
    local Button = Instance.new("TextButton")
    local Symbol = Instance.new("TextLabel")
    local List = Instance.new("ScrollingFrame")
    local ListLayout = Instance.new("UIListLayout")

    local MultiSelect = {self = Label}
    MultiSelect.Name = Name
    MultiSelect.Class = "MultiSelect"
    MultiSelect.Tab = Tab_Name
    MultiSelect.Container = Container_Name
    MultiSelect.Index = #Items + 1
    MultiSelect.Callback = typeof(Callback) == "function" and Callback or function() end
    MultiSelect.Items = typeof(Value_Items) == "table" and Value_Items or {}
    MultiSelect.Value = {}


    local function GetSelectedItems(): table
        local Selected = {}
        for k, v in pairs(MultiSelect.Items) do
            if v == true then table.insert(Selected, k) end
        end
        return Selected
    end

    local function UpdateValue()
        MultiSelect.Value = GetSelectedItems()
        Button.Text = #MultiSelect.Value > 0 and table.concat(MultiSelect.Value, ", ") or "[...]"
    end

    local ItemObjects = {}
    local function AddItem(Name: string, Checked: boolean)
        local Button = Instance.new("TextButton")
        Button.BackgroundColor3 = Menu.ItemColor
        Button.BorderColor3 = Color3.new()
        Button.BorderSizePixel = 0
        Button.Size = UDim2.new(1, 0, 0, 15)
        Button.Font = Enum.Font.SourceSans
        Button.Text = Name
        Button.TextColor3 = Checked and Menu.Accent or Color3.new(1, 1, 1)
        Button.TextSize = 14
        Button.Parent = List
        Button.TextTruncate = Enum.TextTruncate.AtEnd
        Button.MouseButton1Click:Connect(function()
            MultiSelect.Items[Name] = not MultiSelect.Items[Name]
            Button.TextColor3 = MultiSelect.Items[Name] and Menu.Accent or Color3.new(1, 1, 1)
            UpdateValue()
            MultiSelect.Callback(MultiSelect.Items) -- don't send value
        end)
        AddEventListener(Button, function()
            Button.BackgroundColor3 = Menu.ItemColor
            Button.TextColor3 = table.find(GetSelectedItems(), Button.Text) and Menu.Accent or Color3.new(1, 1, 1)
        end)

        if GetDictionaryLength(MultiSelect.Items) >= 6 then
            List.CanvasSize += UDim2.fromOffset(0, 15)
        end
        table.insert(ItemObjects, Button)
    end


    function MultiSelect:Update(Value: any)
        if typeof(Value) == "table" then
            self.Items = Value
            UpdateValue()

            for _, Button in ipairs(ItemObjects) do
                Button:Destroy()
            end
            table.clear(ItemObjects)

            List.CanvasSize = UDim2.new()
            List.Size = UDim2.fromOffset(Button.AbsoluteSize.X, math.clamp(GetDictionaryLength(self.Items) * 15, 15, 90))
            for Name, Checked in pairs(self.Items) do
                AddItem(tostring(Name), Checked)
            end
        else
            local Selected = GetSelectedItems()
            for _, Button in ipairs(ItemObjects) do
                local Checked = table.find(Selected, Button.Text)
                Button.TextColor3 = Checked and Menu.Accent or Color3.new(1, 1, 1)
            end
        end
    end

    function MultiSelect:SetLabel(Name: string)
        Label.Text = tostring(Name)
    end

    function MultiSelect:SetVisible(Visible: boolean)
        if typeof(Visible) ~= "boolean" then return end
        if Label.Visible == Visible then return end
        
        Label.Visible = Visible
        Container:UpdateSize(Visible and 40 or -40, Label)
    end

    function MultiSelect:GetValue(): table
        return self.Items
    end

    function MultiSelect:SetValue(Value: any)
        self:Update(Value)
    end


    Label.MouseEnter:Connect(function()
        if ToolTip then
            Menu:SetToolTip(true, ToolTip, Label)
        end
    end)
    Label.MouseLeave:Connect(function()
        if ToolTip then
            Menu:SetToolTip(false)
        end
    end)

    Button.BackgroundColor3 = Menu.ItemColor
    Button.BorderColor3 = Color3.new()
    Button.Position = UDim2.new(0, 0, 0, 20)
    Button.Size = UDim2.new(1, -40, 0, 15)
    Button.Font = Enum.Font.SourceSans
    Button.Text = "[...]"
    Button.TextColor3 = Color3.new(1, 1, 1)
    Button.TextSize = 14
    Button.TextTruncate = Enum.TextTruncate.AtEnd
    Button.Parent = Label
    Button.MouseButton1Click:Connect(function()
        UpdateSelected(List, Button, UDim2.fromOffset(0, 15))
        List.Size = UDim2.fromOffset(Button.AbsoluteSize.X, math.clamp(GetDictionaryLength(MultiSelect.Items) * 15, 15, 90))
    end)
    AddEventListener(Button, function()
        Button.BackgroundColor3 = Menu.ItemColor
    end)

    Symbol.Name = "Symbol"
    Symbol.BackgroundTransparency = 1
    Symbol.Position = UDim2.new(1, -10, 0, 0)
    Symbol.Size = UDim2.new(0, 5, 1, 0)
    Symbol.Font = Enum.Font.SourceSans
    Symbol.Text = "-"
    Symbol.TextColor3 = Color3.new(1, 1, 1)
    Symbol.TextSize = 14
    Symbol.Parent = Button

    List.Visible = false
    List.BackgroundColor3 = Menu.ItemColor
    List.BorderColor3 = Menu.BorderColor
    List.BorderMode = Enum.BorderMode.Inset
    List.Size = UDim2.fromOffset(Button.AbsoluteSize.X, math.clamp(GetDictionaryLength(MultiSelect.Items) * 15, 15, 90))
    List.Position = UDim2.fromOffset(20, 30)
    List.CanvasSize = UDim2.new()
    List.ScrollBarThickness = 4
    List.ScrollBarImageColor3 = Menu.Accent
    List.Parent = Label
    CreateStroke(List, Color3.new(), 1)
    AddEventListener(List, function()
        List.BackgroundColor3 = Menu.ItemColor
        List.BorderColor3 = Menu.BorderColor
        List.ScrollBarImageColor3 = Menu.Accent
    end)

    ListLayout.Parent = List

    MultiSelect:Update(MultiSelect.Items)
    Container:UpdateSize(40)
    table.insert(Items, MultiSelect)
    return #Items
end


function Menu.ListBox(Tab_Name: string, Container_Name: string, Name: string, Multi: boolean, Value_Items: table, Callback: any, ToolTip: string): ListBox
    local Container = GetContainer(Tab_Name, Container_Name)
    local List = Instance.new("ScrollingFrame")
    local ListLayout = Instance.new("UIListLayout")

    local ListBox = {self = Label}
    ListBox.Name = Name
    ListBox.Class = "ListBox"
    ListBox.Tab = Tab_Name
    ListBox.Container = Container_Name
    ListBox.Index = #Items + 1
    ListBox.Method = Multi and "Multi" or "Default"
    ListBox.Items = typeof(Value_Items) == "table" and Value_Items or {}
    ListBox.Value = {}
    ListBox.Callback = typeof(Callback) == "function" and Callback or function() end

    local ItemObjects = {}

    local function GetSelectedItems(): table
        local Selected = {}
        for k, v in pairs(ListBox.Items) do
            if v == true then table.insert(Selected, k) end
        end
        return Selected
    end

    local function UpdateValue(Value: any)
        if ListBox.Method == "Default" then
            ListBox.Value = tostring(Value)
        else
            ListBox.Value = GetSelectedItems()
        end
    end

    local function AddItem(Name: string, Checked: boolean)
        local Button = Instance.new("TextButton")
        Button.BackgroundColor3 = Menu.ItemColor
        Button.BorderColor3 = Color3.new()
        Button.BorderSizePixel = 0
        Button.Size = UDim2.new(1, 0, 0, 15)
        Button.Font = Enum.Font.SourceSans
        Button.Text = Name
        Button.TextSize = 14
        Button.TextXAlignment = Enum.TextXAlignment.Left
        Button.TextTruncate = Enum.TextTruncate.AtEnd
        Button.Parent = List
        if ListBox.Method == "Default" then
            Button.TextColor3 = ListBox.Value == Button.Text and Menu.Accent or Color3.new(1, 1, 1)
            Button.MouseButton1Click:Connect(function()
                for _, v in ipairs(List:GetChildren()) do
                    if v:IsA("GuiButton") then
                        if v == Button then continue end
                        v.TextColor3 = Color3.new(1, 1, 1)
                    end
                end
                Button.TextColor3 = Menu.Accent
                UpdateValue(Button.Text)
                UpdateSelected()
                ListBox.Callback(ListBox.Value)
            end)
            AddEventListener(Button, function()
                Button.BackgroundColor3 = Menu.ItemColor
                if ListBox.Value == Button.Text then
                    Button.TextColor3 = Menu.Accent
                else
                    Button.TextColor3 = Color3.new(1, 1, 1)
                end
            end)
            
            if #ListBox.Items >= 6 then
                List.CanvasSize += UDim2.fromOffset(0, 15)
            end
        else
            Button.TextColor3 = Checked and Menu.Accent or Color3.new(1, 1, 1)
            Button.MouseButton1Click:Connect(function()
                ListBox.Items[Name] = not ListBox.Items[Name]
                Button.TextColor3 = ListBox.Items[Name] and Menu.Accent or Color3.new(1, 1, 1)
                UpdateValue()
                UpdateSelected()
                ListBox.Callback(ListBox.Value)
            end)
            AddEventListener(Button, function()
                Button.BackgroundColor3 = Menu.ItemColor
                if table.find(ListBox.Value, Name) then
                    Button.TextColor3 = Menu.Accent
                else
                    Button.TextColor3 = Color3.new(1, 1, 1)
                end
            end)
            
            if GetDictionaryLength(ListBox.Items) >= 10 then
                List.CanvasSize += UDim2.fromOffset(0, 15)
            end
        end
        table.insert(ItemObjects, Button)
    end


    function ListBox:Update(Value: string, Items: any)
        if self.Method == "Default" then
            UpdateValue(Value)
        end
        if typeof(Items) == "table" then
            if self.Method == "Multi" then
                self.Items = Value
                UpdateValue()
            end
            for _, Button in ipairs(ItemObjects) do
                Button:Destroy()
            end
            table.clear(ItemObjects)

            List.CanvasSize = UDim2.new()
            List.Size = UDim2.new(1, -50, 0, 150)
            if self.Method == "Default" then
                for _, Item in ipairs(self.Items) do
                    AddItem(tostring(Item))
                end
            else
                for Name, Checked in pairs(self.Items) do
                    AddItem(tostring(Name), Checked)
                end
            end
        else
            if self.Method == "Default" then
                for _, Button in ipairs(ItemObjects) do
                    Button.TextColor3 = self.Value == Button.Text and Menu.Accent or Color3.new(1, 1, 1)
                end
            else
                local Selected = GetSelectedItems()
                for _, Button in ipairs(ItemObjects) do
                    local Checked = table.find(Selected, Button.Text)
                    Button.TextColor3 = Checked and Menu.Accent or Color3.new(1, 1, 1)
                end
            end
        end
    end

    function ListBox:SetVisible(Visible: boolean)
        if typeof(Visible) ~= "boolean" then return end
        if List.Visible == Visible then return end
        
        List.Visible = Visible
        Container:UpdateSize(Visible and 155 or -155, List)
    end

    function ListBox:SetValue(Value: string, Items: any)
        if self.Method == "Default" then
            if typeof(Items) == "table" then
                self.Items = Items
            end
            self:Update(Value, self.Items)
        else
            self:Update(Value)
        end
    end

    function ListBox:GetValue(): table
        return self.Value
    end


    List.Name = "List"
    List.Active = true
    List.BackgroundColor3 = Menu.ItemColor
    List.BorderColor3 = Color3.new()
    List.Position = UDim2.fromOffset(20, Container:GetHeight())
    List.Size = UDim2.new(1, -50, 0, 150)
    List.CanvasSize = UDim2.new()
    List.ScrollBarThickness = 4
    List.ScrollBarImageColor3 = Menu.Accent
    List.Parent = Container.self
    List.MouseEnter:Connect(function()
        if ToolTip then
            Menu:SetToolTip(true, ToolTip, List)
        end
    end)
    List.MouseLeave:Connect(function()
        if ToolTip then
            Menu:SetToolTip(false)
        end
    end)
    CreateStroke(List, Color3.new(), 1)
    AddEventListener(List, function()
        List.BackgroundColor3 = Menu.ItemColor
        List.ScrollBarImageColor3 = Menu.Accent
    end)

    ListLayout.Parent = List

    if ListBox.Method == "Default" then
        ListBox:Update(ListBox.Value, ListBox.Items)
    else
        ListBox:Update(ListBox.Items)
    end
    Container:UpdateSize(155)
    table.insert(Items, ListBox)
    return #Items
end


function Menu.Notify(Content: string, Delay: number)
    assert(typeof(Content) == "string", "missing argument #1, (string expected got " .. typeof(Content) .. ")")
    local Delay = typeof(Delay) == "number" and Delay or 3

    local Text = Instance.new("TextLabel")
    local Notification = {
        self = Text,
        Class = "Notification"
    }

    Text.Name = "Notification"
    Text.BackgroundTransparency = 1
    Text.Position = UDim2.new(0.5, -100, 1, -150 - (GetDictionaryLength(Notifications) * 15))
    Text.Size = UDim2.new(0, 0, 0, 15)
    Text.Text = Content
    Text.Font = Enum.Font.SourceSans
    Text.TextSize = 17
    Text.TextColor3 = Color3.new(1, 1, 1)
    Text.TextStrokeTransparency = 0.2
    Text.TextTransparency = 1
    Text.RichText = true
    Text.ZIndex = 4
    Text.Parent = Notifications_Frame

    local function CustomTweenOffset(Offset: number)
        spawn(function()
            local Steps = 33
            for i = 1, Steps do
                Text.Position += UDim2.fromOffset(Offset / Steps, 0)
                RunService.RenderStepped:Wait()
            end
        end)
    end

    function Notification:Update()
        
    end

    function Notification:Destroy()
        Notifications[self] = nil
        Text:Destroy()

        local Index = 1
        for _, v in pairs(Notifications) do
            local self = v.self
            self.Position += UDim2.fromOffset(0, 15)
            Index += 1
        end
    end

    Notifications[Notification] = Notification
    
    local TweenIn  = TweenService:Create(Text, TweenInfo.new(0.3, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0), {TextTransparency = 0})
    local TweenOut = TweenService:Create(Text, TweenInfo.new(0.2, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0), {TextTransparency = 1})
    
    TweenIn:Play()
    CustomTweenOffset(100)
    
    TweenIn.Completed:Connect(function()
        delay(Delay, function()
            TweenOut:Play()
            CustomTweenOffset(100)

            TweenOut.Completed:Connect(function()
                Notification:Destroy()
            end)
        end)
    end)
end


function Menu.Prompt(Message: string, Callback: any, ...)
    do
        local Prompt = Menu.Screen:FindFirstChild("Prompt")
        if Prompt then Prompt:Destroy() end
    end

    local Prompt = Instance.new("Frame")
    local Title = Instance.new("TextLabel")

    local Height = -20
    local function CreateButton(Text, Callback, ...)
        local Arguments = {...}

        local Callback = typeof(Callback) == "function" and Callback or function() end
        local Button = Instance.new("TextButton")
        Button.Name = "Button"
        Button.BorderSizePixel = 0
        Button.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
        Button.Size = UDim2.fromOffset(100, 20)
        Button.Position = UDim2.new(0.5, -50, 0.5, Height)
        Button.Text = Text
        Button.TextStrokeTransparency = 0.8
        Button.TextSize = 14
        Button.Font = Enum.Font.SourceSans
        Button.TextColor3 = Color3.new(1, 1, 1)
        Button.Parent = Prompt
        Button.MouseButton1Click:Connect(function() Prompt:Destroy() Callback(unpack(Arguments)) end)
        CreateStroke(Button, Color3.new(), 1)
        Height += 25
    end

    CreateButton("OK", Callback, ...)
    CreateButton("Cancel", function() Prompt:Destroy() end)


    Title.Name = "Title"
    Title.BackgroundTransparency = 1
    Title.Size = UDim2.new(1, 0, 0, 15)
    Title.Position = UDim2.new(0, 0, 0.5, -100)
    Title.Text = Message
    Title.TextSize = 14
    Title.Font = Enum.Font.SourceSans
    Title.TextColor3 = Color3.new(1, 1, 1)
    Title.Parent = Prompt

    Prompt.Name = "Prompt"
    Prompt.BackgroundTransparency = 0.5
    Prompt.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    Prompt.BorderSizePixel = 0
    Prompt.Size = UDim2.new(1, 0, 1, 36)
    Prompt.Position = UDim2.fromOffset(0, -36)
    Prompt.Parent = Menu.Screen
end


function Menu.Spectators(): Spectators
    local Frame = Instance.new("Frame")
    local Title = Instance.new("TextLabel")
    local List = Instance.new("Frame")
    local ListLayout = Instance.new("UIListLayout")
    local Spectators = {self = Frame}
    Spectators.List = {}
    Menu.Spectators = Spectators


    Frame.Name = "Spectators"
    Frame.BackgroundColor3 = Color3.fromRGB(10, 10, 10)
    Frame.BorderColor3 = Color3.fromRGB(40, 40, 40)
    Frame.BorderMode = Enum.BorderMode.Inset
    Frame.Size = UDim2.fromOffset(250, 50)
    Frame.Position = UDim2.fromOffset(Menu.ScreenSize.X - Frame.Size.X.Offset, -36)
    Frame.Visible = false
    Frame.Parent = Menu.Screen
    CreateStroke(Frame, Color3.new(), 1)
    CreateLine(Frame, UDim2.new(0, 240, 0, 1), UDim2.new(0, 5, 0, 20))
    SetDraggable(Frame)
    
    Title.Name = "Title"
    Title.BackgroundTransparency = 1
    Title.Position = UDim2.new(0, 5, 0, 5)
    Title.Size = UDim2.new(0, 240, 0, 15)
    Title.Font = Enum.Font.SourceSansSemibold
    Title.Text = "Spectators"
    Title.TextColor3 = Color3.new(1, 1, 1)
    Title.TextSize = 14
    Title.Parent = Frame

    List.Name = "List"
    List.BackgroundColor3 = Color3.fromRGB(15, 15, 15)
    List.BorderColor3 = Color3.fromRGB(40, 40, 40)
    List.BorderMode = Enum.BorderMode.Inset
    List.Position = UDim2.new(0, 4, 0, 30)
    List.Size = UDim2.new(0, 240, 0, 10)
    List.Parent = Frame

    ListLayout.SortOrder = Enum.SortOrder.LayoutOrder
    ListLayout.Parent = List


    local function UpdateFrameSize()
        local Height = ListLayout.AbsoluteContentSize.Y + 5
        Spectators.self:TweenSize(UDim2.fromOffset(250, math.clamp(Height + 50, 50, 5000)), nil, nil, 0.3, true)
        Spectators.self.List:TweenSize(UDim2.fromOffset(240, math.clamp(Height, 10, 5000)), nil, nil, 0.3, true)
    end


    function Spectators.Add(Name: string, Icon: string)
        Spectators.Remove(Name)
        local Object = Instance.new("Frame")
        local NameLabel = Instance.new("TextLabel")
        local IconImage = Instance.new("ImageLabel")
        local Spectator = {self = Object}

        Object.Name = "Object"
        Object.BackgroundTransparency = 1
        Object.Position = UDim2.new(0, 5, 0, 30)
        Object.Size = UDim2.new(0, 240, 0, 15)
        Object.Parent = List

        NameLabel.Name = "Name"
        NameLabel.BackgroundTransparency = 1
        NameLabel.Position = UDim2.new(0, 20, 0, 0)
        NameLabel.Size = UDim2.new(0, 230, 1, 0)
        NameLabel.Font = Enum.Font.SourceSans
        NameLabel.Text = tostring(Name)
        NameLabel.TextColor3 = Color3.new(1, 1, 1)
        NameLabel.TextSize = 14
        NameLabel.TextXAlignment = Enum.TextXAlignment.Left
        NameLabel.Parent = Object

        IconImage.Name = "Icon"
        IconImage.BackgroundTransparency = 1
        IconImage.Image = Icon or ""
        IconImage.Size = UDim2.new(0, 15, 0, 15)
        IconImage.Position = UDim2.new(0, 2, 0, 0)
        IconImage.Parent = Object

        Spectators.List[Name] = Spectator
        UpdateFrameSize()
    end


    function Spectators.Remove(Name: string)
        if Spectators.List[Name] then
            Spectators.List[Name].self:Destroy()
            Spectators.List[Name] = nil
        end
        UpdateFrameSize()
    end


    function Spectators:SetVisible(Visible: boolean)
        self.self.Visible = Visible
    end


    return Spectators
end


function Menu.Keybinds(): Keybinds
    local Frame = Instance.new("Frame")
    local Title = Instance.new("TextLabel")
    local List = Instance.new("Frame")
    local ListLayout = Instance.new("UIListLayout")
    local Keybinds = {self = Frame}
    Keybinds.List = {}
    Menu.Keybinds = Keybinds


    Frame.Name = "Keybinds"
    Frame.BackgroundColor3 = Color3.fromRGB(10, 10, 10)
    Frame.BorderColor3 = Color3.fromRGB(40, 40, 40)
    Frame.BorderMode = Enum.BorderMode.Inset
    Frame.Size = UDim2.fromOffset(250, 45)
    Frame.Position = UDim2.fromOffset(Menu.ScreenSize.X - Frame.Size.X.Offset, -36)
    Frame.Visible = false
    Frame.Parent = Menu.Screen
    CreateStroke(Frame, Color3.new(), 1)
    CreateLine(Frame, UDim2.new(0, 240, 0, 1), UDim2.new(0, 5, 0, 20))
    SetDraggable(Frame)

    Title.Name = "Title"
    Title.BackgroundTransparency = 1
    Title.Position = UDim2.new(0, 5, 0, 5)
    Title.Size = UDim2.new(0, 240, 0, 15)
    Title.Font = Enum.Font.SourceSansSemibold
    Title.Text = "Key binds"
    Title.TextColor3 = Color3.new(1, 1, 1)
    Title.TextSize = 14
    Title.Parent = Frame

    List.Name = "List"
    List.BackgroundColor3 = Color3.fromRGB(15, 15, 15)
    List.BorderColor3 = Color3.fromRGB(40, 40, 40)
    List.BorderMode = Enum.BorderMode.Inset
    List.Position = UDim2.new(0, 4, 0, 30)
    List.Size = UDim2.new(0, 240, 0, 10)
    List.Parent = Frame

    ListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
    ListLayout.SortOrder = Enum.SortOrder.LayoutOrder
    ListLayout.Padding = UDim.new(0, 3)
    ListLayout.Parent = List

    local function UpdateFrameSize()
        local Height = ListLayout.AbsoluteContentSize.Y + 5
        Keybinds.self:TweenSize(UDim2.fromOffset(250, math.clamp(Height + 45, 45, 5000)), nil, nil, 0.3, true)
        Keybinds.self.List:TweenSize(UDim2.fromOffset(240, math.clamp(Height, 10, 5000)), nil, nil, 0.3, true)
    end

    function Keybinds.Add(Name: string, State: string): Keybind
        Keybinds.Remove(Name)
        local Object = Instance.new("Frame")
        local NameLabel = Instance.new("TextLabel")
        local StateLabel = Instance.new("TextLabel")
        local Keybind = {self = Object}

        Object.Name = "Object"
        Object.BackgroundTransparency = 1
        Object.Position = UDim2.new(0, 5, 0, 30)
        Object.Size = UDim2.new(0, 230, 0, 15)
        Object.Parent = List

        NameLabel.Name = "Indicator"
        NameLabel.BackgroundTransparency = 1
        NameLabel.Position = UDim2.new(0, 5, 0, 0)
        NameLabel.Size = UDim2.new(0, 180, 1, 0)
        NameLabel.Font = Enum.Font.SourceSans
        NameLabel.Text = Name
        NameLabel.TextColor3 = Color3.new(1, 1, 1)
        NameLabel.TextSize = 14
        NameLabel.TextXAlignment = Enum.TextXAlignment.Left
        NameLabel.Parent = Object

        StateLabel.Name = "State"
        StateLabel.BackgroundTransparency = 1
        StateLabel.Position = UDim2.new(0, 190, 0, 0)
        StateLabel.Size = UDim2.new(0, 40, 1, 0)
        StateLabel.Font = Enum.Font.SourceSans
        StateLabel.Text = "[" .. tostring(State) .. "]"
        StateLabel.TextColor3 = Color3.new(1, 1, 1)
        StateLabel.TextSize = 14
        StateLabel.TextXAlignment = Enum.TextXAlignment.Right
        StateLabel.Parent = Object

        
        function Keybind:Update(State: string)
            StateLabel.Text = "[" .. tostring(State) .. "]"
        end

        function Keybind:SetVisible(Visible: boolean)
            if typeof(Visible) ~= "boolean" then return end
            if Object.Visible == Visible then return end
        
            Object.Visible = Visible
            UpdateFrameSize()
        end

        
        Keybinds.List[Name] = Keybind
        UpdateFrameSize()

        return Keybind
    end

    function Keybinds.Remove(Name: string)
        if Keybinds.List[Name] then
            Keybinds.List[Name].self:Destroy()
            Keybinds.List[Name] = nil
        end
        UpdateFrameSize()
    end

    function Keybinds:SetVisible(Visible: boolean)
        self.self.Visible = Visible
    end

    function Keybinds:SetPosition(Position: UDim2)
        self.self.Position = Position
    end

    return Keybinds
end


function Menu.Indicators(): Indicators
    local Frame = Instance.new("Frame")
    local Title = Instance.new("TextLabel")
    local List = Instance.new("Frame")
    local ListLayout = Instance.new("UIListLayout")

    local Indicators = {self = Frame}
    Indicators.List = {}
    Menu.Indicators = Indicators

    Frame.Name = "Indicators"
    Frame.BackgroundColor3 = Color3.fromRGB(10, 10, 10)
    Frame.BorderColor3 = Color3.fromRGB(40, 40, 40)
    Frame.BorderMode = Enum.BorderMode.Inset
    Frame.Size = UDim2.fromOffset(250, 45)
    Frame.Position = UDim2.fromOffset(Menu.ScreenSize.X - Frame.Size.X.Offset, -36)
    Frame.Visible = false
    Frame.Parent = Menu.Screen
    CreateStroke(Frame, Color3.new(), 1)
    CreateLine(Frame, UDim2.new(0, 240, 0, 1), UDim2.new(0, 5, 0, 20))
    SetDraggable(Frame)

    Title.Name = "Title"
    Title.BackgroundTransparency = 1
    Title.Position = UDim2.new(0, 5, 0, 5)
    Title.Size = UDim2.new(0, 240, 0, 15)
    Title.Font = Enum.Font.SourceSansSemibold
    Title.Text = "Indicators"
    Title.TextColor3 = Color3.new(1, 1, 1)
    Title.TextSize = 14
    Title.Parent = Frame

    List.Name = "List"
    List.BackgroundColor3 = Color3.fromRGB(15, 15, 15)
    List.BorderColor3 = Color3.fromRGB(40, 40, 40)
    List.BorderMode = Enum.BorderMode.Inset
    List.Position = UDim2.new(0, 4, 0, 30)
    List.Size = UDim2.new(0, 240, 0, 10)
    List.Parent = Frame

    ListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
    ListLayout.SortOrder = Enum.SortOrder.LayoutOrder
    ListLayout.Padding = UDim.new(0, 3)
    ListLayout.Parent = List

    local function UpdateFrameSize()
        local Height = ListLayout.AbsoluteContentSize.Y + 12
        Indicators.self:TweenSize(UDim2.fromOffset(250, math.clamp(Height + 45, 45, 5000)), nil, nil, 0.3, true)
        Indicators.self.List:TweenSize(UDim2.fromOffset(240, math.clamp(Height, 10, 5000)), nil, nil, 0.3, true)
    end

    function Indicators.Add(Name: string, Type: string, Value: string, ...): Indicator
        Indicators.Remove(Name)
        local Object = Instance.new("Frame")
        local NameLabel = Instance.new("TextLabel")
        local StateLabel = Instance.new("TextLabel")

        local Indicator = {self = Object}
        Indicator.Type = Type
        Indicator.Value = Value

        Object.Name = "Object"
        Object.BackgroundTransparency = 1
        Object.Size = UDim2.new(0, 230, 0, 30)
        Object.Parent = Indicators.self.List
        
        NameLabel.Name = "Indicator"
        NameLabel.BackgroundTransparency = 1
        NameLabel.Position = UDim2.new(0, 5, 0, 0)
        NameLabel.Size = UDim2.new(0, 130, 0, 15)
        NameLabel.Font = Enum.Font.SourceSans
        NameLabel.Text = Name
        NameLabel.TextColor3 = Color3.new(1, 1, 1)
        NameLabel.TextSize = 14
        NameLabel.TextXAlignment = Enum.TextXAlignment.Left
        NameLabel.Parent = Indicator.self
    
        StateLabel.Name = "State"
        StateLabel.BackgroundTransparency = 1
        StateLabel.Position = UDim2.new(0, 180, 0, 0)
        StateLabel.Size = UDim2.new(0, 40, 0, 15)
        StateLabel.Font = Enum.Font.SourceSans
        StateLabel.Text = "[" .. tostring(Value) .. "]"
        StateLabel.TextColor3 = Color3.new(1, 1, 1)
        StateLabel.TextSize = 14
        StateLabel.TextXAlignment = Enum.TextXAlignment.Right
        StateLabel.Parent = Indicator.self


        if Type == "Bar" then
            local ObjectBase = Instance.new("Frame")
            local ValueLabel = Instance.new("TextLabel")

            ObjectBase.Name = "Bar"
            ObjectBase.BackgroundColor3 = Color3.fromRGB(15, 15, 15)
            ObjectBase.BorderColor3 = Color3.new()
            ObjectBase.Position = UDim2.new(0, 0, 0, 20)
            ObjectBase.Size = UDim2.new(0, 220, 0, 5)
            ObjectBase.Parent = Indicator.self
    
            ValueLabel.Name = "Value"
            ValueLabel.BorderSizePixel = 0
            ValueLabel.BackgroundColor3 = Menu.Accent
            ValueLabel.Text = ""
            ValueLabel.Parent = ObjectBase
            AddEventListener(ValueLabel, function()
                ValueLabel.BackgroundColor3 = Menu.Accent
            end)
        else
            Object.Size = UDim2.new(0, 230, 0, 15)
        end


        function Indicator:Update(Value: string, ...)
            if Indicators.List[Name] then
                if Type == "Text" then
                    self.Value = Value
                    Object.State.Text = Value
                elseif Type == "Bar" then
                    local Min, Max = select(1, ...)
                    self.Min = typeof(Min) == "number" and Min or self.Min
                    self.Max = typeof(Max) == "number" and Max or self.Max

                    local Scale = (self.Value - self.Min) / (self.Max - self.Min)
                    Object.State.Text = "[" .. tostring(self.Value) .. "]"
                    Object.Bar.Value.Size = UDim2.new(math.clamp(Scale, 0, 1), 0, 0, 5)
                end
                self.Value = Value
            end
        end


        function Indicator:SetVisible(Visible: boolean)
            if typeof(Visible) ~= "boolean" then return end
            if Object.Visible == Visible then return end
            
            Object.Visible = Visible
            UpdateFrameSize()
        end

        
        Indicator:Update(Indicator.Value, ...)
        Indicators.List[Name] = Indicator
        UpdateFrameSize()
        return Indicator
    end


    function Indicators.Remove(Name: string)
        if Indicators.List[Name] then
            Indicators.List[Name].self:Destroy()
            Indicators.List[Name] = nil
        end
        UpdateFrameSize()
    end


    function Indicators:SetVisible(Visible: boolean)
        self.self.Visible = Visible
    end

    function Indicators:SetPosition(Position: UDim2)
        self.self.Position = Position
    end


    return Indicators
end


function Menu.Watermark(): Watermark
    local Watermark = {}
    Watermark.Frame = Instance.new("Frame")
    Watermark.Title = Instance.new("TextLabel")
    Menu.Watermark = Watermark

    Watermark.Frame.Name = "Watermark"
    Watermark.Frame.BackgroundColor3 = Color3.fromRGB(10, 10, 10)
    Watermark.Frame.BorderColor3 = Color3.fromRGB(40, 40, 40)
    Watermark.Frame.BorderMode = Enum.BorderMode.Inset
    Watermark.Frame.Size = UDim2.fromOffset(250, 20)
    Watermark.Frame.Position = UDim2.fromOffset((Menu.ScreenSize.X - Watermark.Frame.Size.X.Offset) - 50, -25)
    Watermark.Frame.Visible = false
    Watermark.Frame.Parent = Menu.Screen
    CreateStroke(Watermark.Frame, Color3.new(), 1)
    CreateLine(Watermark.Frame, UDim2.new(0, 245, 0, 1), UDim2.new(0, 2, 0, 15))
    SetDraggable(Watermark.Frame)

    Watermark.Title.Name = "Title"
    Watermark.Title.BackgroundTransparency = 1
    Watermark.Title.Position = UDim2.new(0, 5, 0, -1)
    Watermark.Title.Size = UDim2.new(0, 240, 0, 15)
    Watermark.Title.Font = Enum.Font.SourceSansSemibold
    Watermark.Title.Text = ""
    Watermark.Title.TextColor3 = Color3.new(1, 1, 1)
    Watermark.Title.TextSize = 14
    Watermark.Title.RichText = true
    Watermark.Title.Parent = Watermark.Frame

    function Watermark:Update(Text: string)
        self.Title.Text = tostring(Text)
    end

    function Watermark:SetVisible(Visible: boolean)
        self.Frame.Visible = Visible
    end

    return Watermark
end


function Menu:Init()
    UserInput.InputBegan:Connect(function(Input: InputObject, Process: boolean) end)
    UserInput.InputEnded:Connect(function(Input: InputObject)
        if (Input.UserInputType == Enum.UserInputType.MouseButton1) then
            Dragging = {Gui = nil, True = false}
        end
    end)
    RunService.RenderStepped:Connect(function(Step: number)
        local Menu_Frame = Menu.Screen.Menu
        Menu_Frame.Position = UDim2.fromOffset(
            math.clamp(Menu_Frame.AbsolutePosition.X,   0, math.clamp(Menu.ScreenSize.X - Menu_Frame.AbsoluteSize.X, 0, Menu.ScreenSize.X    )),
            math.clamp(Menu_Frame.AbsolutePosition.Y, -36, math.clamp(Menu.ScreenSize.Y - Menu_Frame.AbsoluteSize.Y, 0, Menu.ScreenSize.Y - 36))
        )
        local Selected_Frame = Selected.Frame
        local Selected_Item = Selected.Item
        if (Selected_Frame and Selected_Item) then
            local Offset = Selected.Offset or UDim2.fromOffset()
            local Position = UDim2.fromOffset(Selected_Item.AbsolutePosition.X, Selected_Item.AbsolutePosition.Y)
            Selected_Frame.Position = Position + Offset
        end
    
        if Scaling.True then
            MenuScaler_Button.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
            local Origin = Scaling.Origin
            local Size = Scaling.Size
    
            if Origin and Size then
                local Location = UserInput:GetMouseLocation()
                local NewSize = Location + (Size - Origin)
    
                Menu:SetSize(Vector2.new(
                    math.clamp(NewSize.X, Menu.MinSize.X, Menu.MaxSize.X),
                    math.clamp(NewSize.Y, Menu.MinSize.Y, Menu.MaxSize.Y)
                ))
            end
        else
            MenuScaler_Button.BackgroundColor3 = Color3.fromRGB(10, 10, 10)
        end
    
        Menu.Hue += math.clamp(Step / 100, 0, 1)
        if Menu.Hue >= 1 then Menu.Hue = 0 end
    
        if ToolTip.Enabled == true then
            ToolTip_Label.Text = ToolTip.Content
            ToolTip_Label.Position = UDim2.fromOffset(ToolTip.Item.AbsolutePosition.X, ToolTip.Item.AbsolutePosition.Y + 25)
        end
    end)
    Menu.Screen:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
        Menu.ScreenSize = Menu.Screen.AbsoluteSize
    end)
end


  local CrosshairHandler = loadstring(game:HttpGet('https://rentry.co/y36dzarh/raw', true))() do
    getgenv().crosshair.enabled = false
    getgenv().crosshair.color = MainColor
  end
  local ESPHandler = loadstring(game:HttpGet('https://rentry.co/t44o2pao/raw', true))() do
    getgenv().esp.Enabled = false
    getgenv().esp.SkeletonEnabled = false
    getgenv().esp.ChamsEnabled = false
  end

  local YunDrawingApi = loadstring(game:HttpGet('https://raw.githubusercontent.com/caIIed/Librarys/main/Yun%20Api.lua', true))()

  local TargetCircle = YunDrawingApi:New3DCircle() do
    TargetCircle.Visible = false
    TargetCircle.ZIndex = 1
    TargetCircle.Transparency = 1
    TargetCircle.Color = MainColor
    TargetCircle.Thickness = 1
    TargetCircle.Radius = 2
    TargetCircle.Rotation = Vector2.new(2, 0)
end
  
  --// Services
  local Workspace = game:GetService("Workspace")
  local Debris            = game:GetService('Debris');
  local Players = game:GetService("Players")
  local UserInputService = game:GetService('UserInputService')
  local TweenService = game:GetService('TweenService')
  local ContextAction = game:GetService('ContextActionService')
  local Lighting = game:GetService('Lighting')
  local MarketPlace = game:GetService('MarketplaceService')
  local RunService = game:GetService('RunService')
  local ReplicatedStorage = game:GetService('ReplicatedStorage')
  
  --// Variables

  print("CheckPoint 2")
  
  local Target = nil
  local Notification_Icon = "rbxassetid://57254792"
  
  
  local Notifications = {};
  local Utility = {};
  local TracerLine, nigganiggaXD , FakeHitboxPart, DotParent, newBillboard, newFrame, newUiCornor = Drawing.new("Line"), Instance.new("MeshPart"), Instance.new("Part",game.Workspace), Instance.new("Part",game.Workspace), Instance.new("BillboardGui", DotParent), Instance.new("Frame", newBillboard),  Instance.new("UICorner", newFrame)
  local sayMessage = function(msg) ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer(msg, "ALL") end
  task.spawn(function ()
    newBillboard.Name = "endless"
    newBillboard.Adornee = DotParent
    newBillboard.Size = UDim2.new(1, 0, 1, 0)
    newBillboard.AlwaysOnTop = true
    newFrame.Size = UDim2.new(1, 0, 1, 0)
    newFrame.BackgroundTransparency = 0
    newUiCornor.CornerRadius = UDim.new(50, 50)
    DotParent.CanCollide = false
    DotParent.Anchored = true
    DotParent.CFrame = CFrame.new(0,2000,0)
    DotParent.Transparency = 1
    nigganiggaXD.CanCollide = false
    nigganiggaXD.Anchored = true
    nigganiggaXD.Material = Enum.Material.Neon
    nigganiggaXD.Parent = game.Workspace
  end)
  
  local AntiAimViewer_Enabled = false
  local AntiAimViewer_HighLight = false
  local AntiAimViewer_HighLight_OutLineColor = Color3.fromRGB(255, 255, 255)
  local AntiAimViewer_HighLight_FillColor = MainColor
  
  local AntiAimViewer_Color = Color3.fromRGB(255, 102, 204)
  local AntiAimViewer_Target = nil
  local AntiAimViewer_Method = "MousePos"
  
  local Client = Players.LocalPlayer
  local ClientCharacter = Client and (Client.Character or Client.CharacterAdded:Wait())
  local enabled, TargetFalling, DetectAnti, AntiGroundValue, WhenAntiGroundActivate, Script = false, false, true, 0.5, -20, {
    Drawing = {},
    Connections = {},
    Locals = {
        NetworkShouldSleep = false,
        OriginalVelocity = {}
    },
    Functions = {}
}
  local Mouse, Camera = Client:GetMouse(), game:GetService("Workspace").CurrentCamera
  local PreviousPosition, PreviusVelocity = Vector3.new(0,0,0), Vector3.new(0,0,0)
  local req =  (syn and syn.request or request);
  local CFrameSpeedKeyBind
  local flyvariableshit = false
  local chatSpamTick = tick()
  local GuiService   = game:GetService('GuiService');
  local GetGuiInset = GuiService.GetGuiInset


  local EnabledTrashTalkF = true;
  getgenv().UsableTrashTalk = false
  
  
  local raycastParams = RaycastParams.new()
  raycastParams.FilterDescendantsInstances = {Workspace.CurrentCamera, ClientCharacter}
  raycastParams.FilterType = Enum.RaycastFilterType.Exclude
  raycastParams.IgnoreWater = true
  
  --// Tables
  local Notifications = {};
  local Utility = {};
  local FoVCircle = Drawing.new('Circle') do
    FoVCircle.Radius       = 1500
    FoVCircle.Color        = MainColor
    FoVCircle.Filled       = false
    FoVCircle.NumSides     = 120
    FoVCircle.Transparency = 1
    FoVCircle.Visible      = false
end

local TeleportService = game:GetService("TeleportService");
local Desync = {}

local Notifications = {};
local Utility = {};

local List = {
    [16469595315] = {'Del Hood Aim', 'UpdateMousePos', 'MainEvent'},
    [17319408836] = {'OG Da Hood', 'UpdateMousePos', 'MainEvent'},
    [14975320521] = {'Ar Hood', 'UpdateMousePos', 'MainEvent'},
    [17200018150] = {'Hood Of AR', 'UpdateMousePos', 'MainEvent'},
    [15644861772] = {'Flame Hood', 'UpdatQeMousePos', 'MainEvent'},
    [17723797487] = {'Dee Hood', 'UpdateMousePosI', 'MainEvent'},
    [17897702920] = {'Og Da Hood', 'UpdateMousePos', 'MainEvent'},
    [17809101348] = {'New Hood', 'UpdateMousePos', 'MainEvent'},
    [17344804827] = {'Yeno Hood', 'UpdateMousePos', 'MainEvent'},
    [16435867341] = {'Mad Hood', 'UpdateMousePos', 'MainEvent'},
    [14412601883] = {'Hood Bank', 'MOUSE', 'MAINEVENT'},
    [14412436145] = {'Da Uphill', 'MOUSE', 'MAINEVENT'},
    [14487637618] = {'Da Hood Bot Aim Trainer', 'MOUSE', 'MAINEVENT'},
    [11143225577] = {'1v1 Hood Aim Trainer', 'UpdateMousePos', 'MainEvent'},
    [14413712255] = {'Hood Aim', 'MOUSE', 'MAINEVENT'},
    [12927359803] = {'Dah Aim Trainer', 'UpdateMousePos', 'MainEvent'},
    [12867571492] = {'Katana Hood', 'UpdateMousePos', 'MainEvent'},
    [11867820563] = {'Dae Hood', 'UpdateMousePos', 'MainEvent'},
    [17109142105] = {'Da Battles', 'MoonUpdateMousePos', 'MainEvent'},
    [15186202290] = {'Da Strike', 'MOUSE', 'MAINEVENT'},
    [2788229376] = {'Da Hood', 'UpdateMousePosI', 'MainEvent'},
    [16033173781] = {'Da Hood Macro', 'UpdateMousePosI', 'MainEvent'},
    [7213786345] = {'Da Hood VC', 'UpdateMousePosI', 'MainEvent'},
    [9825515356] = {'Hood Customs', 'MousePosUpdate', 'MainEvent'},
    [17895632819] = {'Hood Spirit', 'UpdateMousePos', 'MainEvent'},
    [5602055394] = {'Hood Modded', 'MousePos', 'Bullets'},
    [7951883376] = {'Hood Modded VC', 'MousePos', 'Bullets'},
    [9183932460] = {'Untitled Hood', 'UpdateMousePos', '.gg/untitledhood'},
    [14412355918] = {'Da Downhill', 'MOUSE', 'MAINEVENT'}
}

local ItemTable = {
    ['Guns'] = {
        ['LMG'] = '[LMG] - $3978';
        ['AK-47'] = '[AK47] - $2387';
        ['Silencer AR'] = '[SilencerAR] - $1326';
        ['Silencer'] = '[Silencer] - $583';
        ['Revolver'] = '[Revolver] - $1379';
        ['AR'] = '[AR] - $1061';
        ['AUG'] = '[AUG] - $2069';
        ['Double-Barrel'] = '[Double-Barrel SG] - $1432';
        ['Drum Gun'] = '[DrumGun] - $3183';
        ['Flamethrower'] = '[Flamethrower] - $15914';
        ['Glock'] = '[Glock] - $318';
        ['P90'] = '[P90] - $1061';
        ['RPG'] = '[RPG] - $6365';
        ['Rifle'] = '[Rifle] - $1644';
        ['SMG'] = '[SMG] - $796';
        ['Shotgun'] = '[Shotgun] - $1326';
        ['Tactical Shotgun'] = '[TacticalShotgun] - $1857';
    };

    ['Ammo'] = {
        ['LMG'] = '200 [LMG Ammo] - $318';
        ['AK-47'] = '90 [AK47 Ammo] - $85';
        ['Silencer AR'] = '120 [SilencerAR Ammo] - $80';
        ['Silencer'] = '25 [Silencer Ammo] - $53';
        ['Revolver'] = '12 [Revolver Ammo] - $80';
        ['AR'] = '100 [AR Ammo] - $80';
        ['AUG'] = '90 [AUG Ammo] - $85';
        ['Double-Barrel'] = '18 [Double-Barrel SG Ammo] - $53';
        ['Drum Gun'] = '100 [DrumGun Ammo] - $212';
        ['Flamethrower'] = '140 [Flamethrower Ammo] - $1644';
        ['Glock'] = '25 [Glock Ammo] - $64';
        ['P90'] = '120 [P90 Ammo] - $64';
        ['RPG'] = '5 [RPG Ammo] - $1061';
        ['Rifle'] = '5 [Rifle Ammo] - $265';
        ['SMG'] = '80 [SMG Ammo] - $64';
        ['Shotgun'] = '20 [Shotgun Ammo] - $64';
        ['Tactical Shotgun'] = '20 [TacticalShotgun Ammo] - $64';
    };

    ['Armor'] = {
        ['High'] = '[High-Medium Armor] - $2440';
        ['Medium'] = '[Medium Armor] - $1061';
        ['Fire'] = '[Fire Armor] - $2493';
    };
};

  local AssetTable = {
      Sounds = {
          ['None']         = '',
          ['OSU']          = 'rbxassetid://7147454322',
          ['Neverlose']    = 'rbxassetid://7216848832',
          ['Bameware']     = 'rbxassetid://3124331820',
          ['Hitmarker']    = 'rbxassetid://160432334',
          ['skeet']        = 'rbxassetid://4817809188',
          ['Rust']         = 'rbxassetid://5043539486',
          ['Lazer Beam']   = 'rbxassetid://130791043',
          ['Bow Hit']      = 'rbxassetid://1053296915',
          ['Bow']          = 'rbxassetid://3442683707',
          ['TF2 Hitsound'] = 'rbxassetid://3455144981',
          ['TF2 Critical'] = 'rbxassetid://296102734',
      };
      Textures = {
          ['Normal'] = 'rbxassetid://7151778302',
          ['Fog'] = 'rbxassetid://9150635648',
      };
  };
  
  local ItemTableValues = {Sounds = {}, Guns = {}, Ammo = {}}; do 
  
      for i, v in pairs(AssetTable.Sounds) do
          table.insert(ItemTableValues.Sounds, i)
      end

      for i, v in pairs(ItemTable.Guns) do 
        table.insert(ItemTableValues.Guns, i)
    end 

    for i, v in pairs(ItemTable.Ammo) do 
        table.insert(ItemTableValues.Ammo, i)
    end 
  
  end 
  
  local Settings = {
    ['AntiAim'] = {
        ['InvisibleDesync'] = { ['Enabled'] = false;
            ['X'] = {['Start'] = -16000; ['End'] = 16000;};
            ['Y'] = {['Start'] = -16000; ['End'] = 16000;};
            ['Z'] = {['Start'] = -16000; ['End'] = 16000;};
        }
    },

    ['Destroy Cheaters'] = {
        Enabled = false,
        Keybind = Enum.KeyCode.G,
    };

    ['Combat'] = {
        ['TargetLock'] = {
            Enabled = false,
            Predict = true,
            KeyBind = Enum.KeyCode.T,
            Prediction = 0.135,
            HitParts = 'HumanoidRootPart',
            NearestPart = false,
            HitPartMode = 'Nearest Point',
            Notifications = false,
        },
        ['Stuff'] = {
            LookAt = false,
            Spectate = false,
            Notification = false,
            AutoPrediction = true,
        },
        ['Checks'] = {
            Resolver = true,
            ResolverMethod = 'Recaculate',
            AimviewerBypass = true,
            NoGroundShots = true,
            Knocked = true,
            Grabbed = false,
            Friend = false,
            Crew = false,
            AntiCurve = true,
            WallCheck = true,
        },
        ['Visuals'] = {
            ['Line'] = {
                Enabled = true,
                Circle = true,
                Visible = true,
                Color = MainColor,
                Transparency = 1,
                Thickness = 2,
            },
            ['HighLight'] = {
                Enabled = true,
                Transparency = 0,
                FillColor = MainColor,
                OutLineColor = Color3.fromRGB(255, 255, 255),
            },
            ['BackTrack'] = {
                Enabled = true,
                Material = 'ForceField',
                Color = MainColor,
                Delay = 0.1,
                Transparency = 0,
            },
        },
    };
  
    ['Visuals'] = {
        ['Weapon_Chams'] = {
            Enabled = false,
            Material = Enum.Material.SmoothPlastic,
            Color = MainColor,
        },
        ['Character_Chams'] = {
            Enabled = false,
            Material = Enum.Material.ForceField,
            Color = MainColor,

            Trail = false,
            Trail_Color = MainColor,
            Trail_Life = 3,
        },
        ['World_Customization'] = {
            Enabled = false,

            Bars = false,
            BarsColor = MainColor,
        },
        ['Bullet_Trails'] = {
            Enabled = false,
            Magnitude = 12,
            Width = 1.7,
            Brightness = 5,
            Segments = 10,
            LightEmission = 10,
            Color = ColorSequence.new({ColorSequenceKeypoint.new(0, Color3.fromRGB(240, 175, 235)), ColorSequenceKeypoint.new(1, Color3.fromRGB(240, 175, 235))}),
            Speed = 3,
            Texture = 'Normal', -- 12781803086
        },
        ['Hit_Detection'] = {
          Enabled = false,
  
          Notify = true,
          Clone = true,
          Pulse = false,
          Sound = true,
          HitSound = 'Rust',
        },
    };
  
    ['Misc'] = {
        ['Auto_Buy'] = {
            Gun = 'LMG',
        },
        ['Random'] = {
            AutoStomp = false,
            AntiBag = false,
            NoJumpCooldown = false,
            NoSlow = false,
            NoRecoil = false,
        },
        ['Cash'] = {
            AutoDrop = false,
            Amount = 8000,
            AutoPick = false,
        },
        ['NetworkAnti'] = {
            Enabled = false,
            Notification = true,
            Keybind = Enum.KeyCode.K
        },
        ['PredictionDisabler'] = {
            Enabled = false,
            KeyBind = Enum.KeyCode.X,
            Notifications = false,
            Errors = false,
            AutoWalkSpeed = false,
            AnimationSpeed = 21,
            WalkSpeed = 12,
        },
        ['TargetStrafe'] = {
            Enabled = false,
            Visualize_Circle = false,
            Color = Color3.fromRGB(255, 194, 254),
            Distance = 9,
            Speed = 1,
            Height = 0,
  
            Method = 'Strafe', -- Strafe, Randomize
            RandomizeMin = 2,
            RandomizeMax = 17,

            AutoFire = true,
            AutoReload = true,
        },
        ['Fly'] = {
            Enabled = false,
            Notification = false,
            KeyBind = Enum.KeyCode.X,
            Speed = 5 * 50,
        },
        ['WalkSpeed'] = {
            Enabled = false,
            Notifications = false,
            KeyBind = Enum.KeyCode.X,
            Speed = 1,
        },
        ['TrashTalk'] = {
            ['Use'] = {
                Enabled = false,
                Target = false,
                Notification = false,
                UsekeyBind = false,
                KeyBind = Enum.KeyCode.B,
                Method = "Misery",
            },
            ['Words'] = {
                Misery = {"do you have $$$$mmMMIIEERRY!!!", "MoveDirection isn't a resolver", "Skid", "WHERE BRO AIMING AT!?", "Lost 2 Misery", "omg so bad", "imagine dying to me", "whats the point of playing with that aim", "WOWZIES", "OH MY DAYS", "Misery'd", "1d luh bro", "WOW U SUCK", "Im right here", "couldnt be me", "just broke ur ankles", "UR ANKLES? GONE?", "destroyed", "LOL DESTROYED", "LOL"},
            },
        },
    };
  
    ['Configs'] = {
        Menu = {
            Keybind = Enum.KeyCode.P,
        },
    };
  };
  
  print("CheckPoint 3")
  
  
  getgenv().MethodBeingUsed = Settings.Misc.TrashTalk.Words.Misery
  
  -- // functions

function Script.Functions.Connection(event, func)
    return event:Connect(func)
end

local function DestroyCheaters()
    Settings['Destroy Cheaters'].Enabled = not Settings['Destroy Cheaters'].Enabled;

    if Settings['Destroy Cheaters'].Enabled then
        local Character = Client and Client.Character
        if Character then
            local RootPart = Character and Character:FindFirstChild('HumanoidRootPart')
            local Position = RootPart and RootPart.CFrame
    
            task.wait()

            while task.wait(2) do
                Desync.cframe = (RootPart.CFrame * CFrame.new(9e9, 0/0, 9e9))
        
                task.wait(1)
    
                Desync.cframe = Position
                task.wait()
                Desync.cframe = nil
            end

        end

    end
end

Script.Functions.Update_Desync = function(bool)
    Settings.AntiAim.InvisibleDesync.Enabled = bool 

    if (not bool) then 
        if (Script.Connections['Invisible Desync']) then 
            Script.Connections['Invisible Desync']:Disconnect()
            Script.Connections['Invisible Desync'] = nil 
        end

        setfflag('S2PhysicsSenderRate', 15)
        setfflag('PhysicsSenderMaxBandwidthBps', 38760)
        sethiddenproperty(Client.Character.HumanoidRootPart, "NetworkIsSleeping", false)
    end
end


--[[

Script.Functions.InvisibleDesync = function()   
    local NetworkShouldSleep = false
    if not Script.Connections["Invisible Desync"] then
        Script.Connections["Invisible Desync"] = Script.Functions.Connection(RunService.Heartbeat, function()
            if (not Settings.AntiAim.InvisibleDesync.Enabled) then return end 

            Script.Locals.NetworkShouldSleep = not Script.Locals.NetworkShouldSleep
            setfflag("S2PhysicsSenderRate", tostring(2)) 
            setfflag("PhysicsSenderMaxBandwidthBps", tostring(math.pi/3))

            sethiddenproperty(Client.Character.HumanoidRootPart, "NetworkIsSleeping", Script.Locals.NetworkShouldSleep)
            Script.Locals.OriginalVelocity[1] = Client.Character.HumanoidRootPart.Velocity
            Script.Locals.OriginalVelocity[2] = Client.Character.HumanoidRootPart.AssemblyLinearVelocity

            Client.Character.HumanoidRootPart.Velocity = Client.Character.HumanoidRootPart.Velocity + Vector3.new(math.random(Settings.AntiAim.InvisibleDesync.X['Start'], Settings.AntiAim.InvisibleDesync.X['End']), math.random(Settings.AntiAim.InvisibleDesync.Y['Start'], Settings.AntiAim.InvisibleDesync.Y['End']), math.random(Settings.AntiAim.InvisibleDesync.Z['Start'], Settings.AntiAim.InvisibleDesync.Z['End']))
            Client.Character.HumanoidRootPart.AssemblyLinearVelocity = Client.Character.HumanoidRootPart.AssemblyLinearVelocity + Vector3.new(math.random(Settings.AntiAim.InvisibleDesync.X['Start'], Settings.AntiAim.InvisibleDesync.X['End']), math.random(Settings.AntiAim.InvisibleDesync.Y['Start'], Settings.AntiAim.InvisibleDesync.Y['End']), math.random(Settings.AntiAim.InvisibleDesync.Z['Start'], Settings.AntiAim.InvisibleDesync.Z['End']))

            RunService.RenderStepped:Wait()

            Client.Character.HumanoidRootPart.Velocity = Script.Locals.OriginalVelocity[1]
            Client.Character.HumanoidRootPart.AssemblyLinearVelocity = Script.Locals.OriginalVelocity[2]
            setfflag("S2PhysicsSenderRate", tostring(1))
            NetworkShouldSleep = not NetworkShouldSleep
        end)
    end
    RunService.RenderStepped:Wait()
    sethiddenproperty(Client.Character.HumanoidRootPart, "NetworkIsSleeping", NetworkShouldSleep)
    setfflag("S2PhysicsSenderRate", tostring(15))
end

Script.Functions.InvisibleDesync()
]]
local function ToggleTrail(Bool)
    for i,v in pairs(game.Players.LocalPlayer.Character:GetChildren()) do
        if v:IsA("BasePart") then
            if Bool then
                local BlaBla = Instance.new("Trail", v)
                BlaBla.Texture = "rbxassetid://1390780157"
                BlaBla.Parent = v
                local Pointer1 = Instance.new("Attachment", v)
                Pointer1.Name = "Pointer1"
                local Pointer2 = Instance.new("Attachment", game.Players.LocalPlayer.Character.HumanoidRootPart)
                Pointer2.Name = "Pointer2"
                BlaBla.Attachment0 = Pointer1
                BlaBla.Attachment1 = Pointer2
                BlaBla.Color = ColorSequence.new({ColorSequenceKeypoint.new(0, Settings.Visuals.Character_Chams.Trail_Color), ColorSequenceKeypoint.new(1, Settings.Visuals.Character_Chams.Trail_Color)});
                BlaBla.Lifetime = Settings.Visuals.Character_Chams.Trail_Life
                BlaBla.Name = "BlaBla" -- Set the name
            else
                for _, child in ipairs(v:GetChildren()) do
                    if child:IsA("Trail") and child.Name == 'BlaBla' then -- Corrected the condition
                        child:Destroy()
                    end
                end
            end
        end
    end
end

local function AutoBuy(Obj, Ammo, Amount)
    local Character = Client and (Client.Character or Client.CharacterAdded:Wait())
    local RootPart  = Character and Character.HumanoidRootPart
    local RootPos   = RootPart.CFrame

    local ObjectPath = Workspace.Ignored.Shop[Obj]
    local ClickDet   = ObjectPath.ClickDetector

    if Character and Ammo then
        for i = 1, Amount do
            RootPart.CFrame = ObjectPath.Head.CFrame
            task.wait(0.3)
            fireclickdetector(ClickDet)
            task.wait(0.15)
        end

        RootPart.CFrame = RootPos
    else
        RootPart.CFrame = ObjectPath.Head.CFrame
        task.wait(0.15)
        fireclickdetector(ClickDet)
        task.wait(0.15)
        RootPart.CFrame = RootPos
    end
end


  function Alive(Player)
    if Player and Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") ~= nil and Player.Character:FindFirstChild("Humanoid") ~= nil and Player.Character:FindFirstChild("Head") ~= nil then
        return true
    end
    return false
  end
  
  local function GetTool()
    local Character = Client.Character 
    local Tool = nil 

    if (not Character) then 
        return Tool
    end

    for _, v in pairs(Character:GetChildren()) do 
        if (not v:IsA('Tool')) then continue end 

        if (v:FindFirstChild('Ammo') and v:FindFirstChild('MaxAmmo')) then 
            Tool = v 
        end
    end

    return Tool
end
  
  function findPlayerByUsername(username)
    for _, player in ipairs(game.Players:GetPlayers()) do
        if player.Name == username then
            return player
        end
    end
    return nil  -- Player not found
  end

  local function FindPlayer(Player)
    for i, v in pairs(Players:GetPlayers()) do
        if (v.Name:lower():find(Player:lower())) then
            if v.Name == Client.name then continue end
            return v
        end
    end
end

  
  
  --\\ Ui
  local Menu = loadstring(req({Url = "https://pastebin.com/raw/55iKqxgB", Method = "Get"}).Body)(); -- WYVJcRAt

    local function MenuNameUpdate()
        while (task.wait()) do
            local Name, PlaceHolder = 'Misery Solara Version - Colloper Was Here :3', ''
            for i = 1, #Name do --try
                local Character = string.sub(Name, i, i)
                PlaceHolder = PlaceHolder .. Character
                Menu:SetTitle(PlaceHolder .. '<font color="#' .. tostring(Menu.Accent:ToHex()) .. '">.cc</font>')
                task.wait(.25)
            end
        end
    end
  
    --// functions
    local function MenuToggle(Action_Name: string, State: EnumItem, Input: InputObject)
        if not State or State == Enum.UserInputState.Begin then
            Menu:SetVisible(not Menu.IsVisible)
        end
    end
  
    task.spawn(MenuNameUpdate)
  
    Menu.Accent = MainColor

    Menu.Keybinds = Menu.Keybinds() do
        Menu.Keybinds.Add('Fly', Settings.Misc.Fly.Enabled and 'On' or 'Off')
        Menu.Keybinds.Add('CFrame', Settings.Misc.WalkSpeed.Enabled and 'On' or 'Off')
        Menu.Keybinds.Add('Prediction Breaker', Settings.Misc.PredictionDisabler.Enabled and 'On' or 'Off')
    end

    Menu.Indicators = Menu.Indicators() do
        Menu.Indicators.Add('Target', 'Text', 'nil')
        Menu.Indicators.Add('Target Health', 'Bar', 50, 0, 100) -- Value, Min, Max
        Menu.Indicators.Add('Target Armor', 'Bar', 100, 0, 200) -- Value, Min, Max

        Menu.Indicators.Add('Knocked Out', 'Text', 'True')
        Menu.Indicators.Add('Anti Aiming', 'Text', 'True')
        Menu.Indicators.Add('Target Ammo', 'Bar', 50, 0, 200) -- Value, Min, Max
        --Menu.Indicators:SetPosition(UDim2.new(0, 39, 0, 281))
    end
    Menu.Watermark()
    Menu.Watermark:Update('Misery<font color="#' .. tostring(Menu.Accent:ToHex()) .. '">.cc</font>') -- please fix this and we can add a variable for a color.
  
    local Window = Menu:SetTitle('Misery') do
  
        local CombatTab = Menu.Tab("Main") do
  
            local TargetAimSection = Menu.Container("Main", "Target Aim", "Left") do
                Menu.CheckBox("Main", "Target Aim", "Enabled", false, function(a)
                    Settings.Combat.TargetLock.Enabled = a
                end)
                Menu.Hotkey("Main", "Target Aim", "Keybind", Enum.KeyCode.T, function(a)
                    Settings.Combat.TargetLock.KeyBind = a
                end)
                Menu.CheckBox("Main", "Target Aim", "Look At", false, function(a)
                    Settings.Combat.Stuff.LookAt = a
                end)
                Menu.CheckBox("Main", "Target Aim", "Spectate", false, function(a)
                    Settings.Combat.Stuff.Spectate = a
                end)
                Menu.CheckBox("Main", "Target Aim", "Notification", false, function(a)
                    Settings.Combat.Stuff.Notification = a
                end)
            end
  
            local HitPartSection = Menu.Container("Main", "HitPart", "Left") do
                Menu.CheckBox("Main", "HitPart", "NearestPart", false, function(a)
                    Settings.Combat.TargetLock.NearestPart = a
                end)
                Menu.ComboBox("Main", "HitPart", "NearestPart Mode", "Nearest Part", {"Nearest Point", "Nearest Part"}, function(a)
                    Settings.Combat.TargetLock.HitPartMode = a
                end)
                Menu.ComboBox("Main", "HitPart", "HitPart", "HumanoidRootPart", {"Head", "LeftHand", "RightHand", "LeftLowerArm", "RightLowerArm", "LeftUpperArm", "RightUpperArm", "LeftFoot", "LeftLowerLeg", "UpperTorso", "HumanoidRootPart", "LeftUpperLeg", "RightLowerLeg", "RightFoot", "LowerTorso"}, function(a)
                    Settings.Combat.TargetLock.HitParts = a
                end)
            end
  
            local PredictionSection = Menu.Container("Main", "Prediction", "Left") do
                Menu.CheckBox("Main", "Prediction", "Enabled", true, function(a)
                    Settings.Combat.TargetLock.Predict = a
                end)
                Menu.CheckBox("Main", "Prediction", "Auto Prediction", true, function(a)
                    Settings.Combat.Stuff.AutoPrediction = a
                end)
                Menu.TextBox("Main", "Prediction", "Prediction", '0.135', function(a)
                    Settings.Combat.TargetLock.Prediction = a
                end)
            end
  
            local ChecksSection = Menu.Container("Main", "Checks", "Left") do
                Menu.CheckBox("Main", "Checks", "No Ground Shots", true, function(a)
                    Settings.Combat.Checks.NoGroundShots = a
                end)
                Menu.CheckBox("Main", "Checks", "Anti Curve", true, function(a)
                    Settings.Combat.Checks.AntiCurve = a
                end)
                Menu.CheckBox("Main", "Checks", "Knocked Check", true, function(a)
                    Settings.Combat.Checks.Knocked = a
                end)
                Menu.CheckBox("Main", "Checks", "Grabbed Check", false, function(a)
                    Settings.Combat.Checks.Grabbed = a
                end)
                Menu.CheckBox("Main", "Checks", "Crew Check", false, function(a)
                    Settings.Combat.Checks.Crew = a
                end)
                Menu.CheckBox("Main", "Checks", "Friend Check", false, function(a)
                    Settings.Combat.Checks.Friend = a
                end)
                Menu.CheckBox("Main", "Checks", "Wall Check", true, function(a)
                    Settings.Combat.Checks.WallCheck = a
                end)
            end
  
            local TSSection = Menu.Container("Main", "Target Strafe", "Right") do
                Menu.CheckBox("Main", "Target Strafe", "Enabled", false, function(a)
                    Settings.Misc.TargetStrafe.Enabled = a
                end)
                Menu.ComboBox("Main", "Target Strafe", "Method", "Strafe", {"Strafe", "Randomize"}, function(a)
                  Settings.Misc.TargetStrafe.Method = a
              end)
                Menu.CheckBox("Main", "Target Strafe", "Visualize", false, function(a)
                    Settings.Misc.TargetStrafe.Visualize_Circle = a
                end)
                Menu.CheckBox("Main", "Target Strafe", "Auto Fire", true, function(a)
                    Settings.Misc.TargetStrafe.AutoFire = a
                end)
                Menu.CheckBox("Main", "Target Strafe", "Auto Reload", true, function(a)
                    Settings.Misc.TargetStrafe.AutoReload = a
                end)
                Menu.ColorPicker("Main", "Target Strafe", "Color", MainColor, 0, function(a)
                    Settings.Misc.TargetStrafe.Color = a
                end)
                Menu.Slider("Main", "Target Strafe", "Distance", 0, 50, 9, '', 1, function(a)
                    Settings.Misc.TargetStrafe.Distance = a
                end)
                Menu.Slider("Main", "Target Strafe", "Speed", 0, 15, 1, '', 1, function(a)
                    Settings.Misc.TargetStrafe.Speed = a
                end)
                Menu.Slider("Main", "Target Strafe", "Height", 0, 15, 0, '', 1, function(a)
                    Settings.Misc.TargetStrafe.Height = a
                end)
                Menu.Slider('Main', 'Target Strafe', 'Teleport Min', 1, 20, 2, '', 1, function(Value)
                  Settings.Misc.TargetStrafe.RandomizeMin = Value
              end)
              Menu.Slider('Main', 'Target Strafe', 'Teleport Max', 2, 40, 17, '', 1, function(Value)
                  Settings.Misc.TargetStrafe.RandomizeMax = Value
              end)
  
            end
  
            local HitDetectionSection = Menu.Container("Main", "Hit Detection", "Right") do
              Menu.CheckBox("Main", "Hit Detection", "Enabled", false, function(a)
                  Settings.Visuals.Hit_Detection.Enabled = a
              end)
              Menu.CheckBox("Main", "Hit Detection", "Hit Sound", false, function(a)
                  Settings.Visuals.Hit_Detection.Sound = a
              end)
              Menu.CheckBox("Main", "Hit Detection", "Notify", false, function(a)
                  Settings.Visuals.Hit_Detection.Notify = a
              end)
              Menu.ComboBox('Main', 'Hit Detection', 'Sounds', 'Rust', ItemTableValues.Sounds, function(self)
                  Settings.Visuals.Hit_Detection.HitSound = self
              end)
              Menu.MultiSelect('Main', 'Hit Detection', 'Hit Effects', {
                  ['Clone'] = Settings.Visuals.Hit_Detection.Clone,
                  ['Pulse'] = Settings.Visuals.Hit_Detection.Pulse,
              }, function(Selection)
                  Settings.Visuals.Hit_Detection.Clone = Selection['Clone']
                  Settings.Visuals.Hit_Detection.Pulse = Selection['Pulse']
              end)
  
            end
  
  
        end
  
        local MiscTab = Menu.Tab("Misc") do
  
            local MTSection1 = Menu.Container("Misc", "Prediction Breaker", "Left") do
                Menu.CheckBox("Misc", "Prediction Breaker", "Enabled", false, function(a)
                    Settings.Misc.PredictionDisabler.Enabled = a
                end)
                Menu.Hotkey("Misc", "Prediction Breaker", "Keybind", Enum.KeyCode.X, function(a)
                    Settings.Misc.PredictionDisabler.KeyBind = a
                end)
                Menu.CheckBox("Misc", "Prediction Breaker", "Notifications", false, function(a)
                    Settings.Misc.PredictionDisabler.Notifications = a
                end)
                Menu.CheckBox("Misc", "Prediction Breaker", "Errors", false, function(a)
                    Settings.Misc.PredictionDisabler.Errors = a
                end)
                Menu.CheckBox("Misc", "Prediction Breaker", "Auto Settings", false, function(a)
                    Settings.Misc.PredictionDisabler.AutoWalkSpeed = a
                end)
                Menu.Slider("Misc", "Prediction Breaker", "Animation Speed", 0, 50, 21, '%', 1, function(a)
                    Settings.Misc.PredictionDisabler.AnimationSpeed = a
                end)
                Menu.Slider("Misc", "Prediction Breaker", "Walk Speed", 0, 50, 12, '%', 1, function(a)
                    Settings.Misc.PredictionDisabler.WalkSpeed = a
                end)
            end
  
            local MTSection2 = Menu.Container("Misc", "CFrame Speed", "Right") do
                Menu.CheckBox("Misc", "CFrame Speed", "Enabled", false, function(a)
                    Settings.Misc.WalkSpeed.Enabled = a
                end)
                Menu.Hotkey("Misc", "CFrame Speed", "Keybind", Enum.KeyCode.X, function(a)
                    Settings.Misc.WalkSpeed.KeyBind = a
                end)
                Menu.CheckBox("Misc", "CFrame Speed", "Notification", false, function(a)
                    Settings.Misc.WalkSpeed.Notifications = a
                end)
                Menu.Slider("Misc", "CFrame Speed", "Speed", 0, 10, 3, '%', 1, function(a)
                    Settings.Misc.WalkSpeed.Speed = a
                end)
            end
  
            local MTSection3 = Menu.Container("Misc", "Fly", "Right") do
                Menu.CheckBox("Misc", "Fly", "Enabled", false, function(a)
                    Settings.Misc.Fly.Enabled = a
                end)
                Menu.Hotkey("Misc", "Fly", "Keybind", Enum.KeyCode.X, function(a)
                    Settings.Misc.Fly.KeyBind = a
                end)
                Menu.CheckBox("Misc", "Fly", "Notification", false, function(a)
                    Settings.Misc.Fly.Notification = a
                end)
                Menu.Slider("Misc", "Fly", "Speed", 0, 30, 5, '%', 1, function(a)
                    Settings.Misc.Fly.Speed = a * 50
                end)
            end
  
            local MTSection4 = Menu.Container("Misc", "Trash Talk", "Left") do
                Menu.CheckBox("Misc", "Trash Talk", "Enabled", false, function(a)
                    Settings.Misc.TrashTalk.Use.Enabled = a
                end)
                Menu.CheckBox("Misc", "Trash Talk", "Target", false, function(a)
                    Settings.Misc.TrashTalk.Use.Target = a
                end)
                Menu.CheckBox("Misc", "Trash Talk", "Notification", false, function(a)
                    Settings.Misc.TrashTalk.Use.Notification = a
                end)
                Menu.CheckBox("Misc", "Trash Talk", "Use Keybind", false, function(a)
                    Settings.Misc.TrashTalk.Use.UsekeyBind = a
                end)
                Menu.Hotkey("Misc", "Trash Talk", "Keybind", Enum.KeyCode.B, function(a)
                    Settings.Misc.TrashTalk.Use.KeyBind = a
                end)
            end
  
            local MTSection4 = Menu.Container("Misc", "Network Anti", "Left") do
                Menu.CheckBox("Misc", "Network Anti", "Enabled", false, function(a)
                    Settings.Misc.NetworkAnti.Enabled = a
                end)
                Menu.Hotkey("Misc", "Network Anti", "Keybind", Enum.KeyCode.K, function(a)
                    Settings.Misc.NetworkAnti.KeyBind = a
                end)
                Menu.CheckBox("Misc", "Network Anti", "Notification", false, function(a)
                    Settings.Misc.NetworkAnti.Notification = a
                end)
            end
  
            local MTSection5 = Menu.Container("Misc", "Teleport", "Right") do
                Menu.ComboBox("Misc", "Teleport", "Place :", "Choose", {"Admin Base","Military","Revolver","High Medium Armor","Food","Gas Station","School","Ufo","Bank","Gym Top","Casino","Uphill","PlayGround","Flank"}, function(State)
                    local CFrameValues = {
                        ["Admin Base"] = CFrame.new(-874.903992, -32.6492004, -525.215698),
                        ["High Medium Armor"] = CFrame.new(-934.73651123047, -28.492471694946, 565.99884033203),
                        ["Food"] = CFrame.new(-788.39318847656, -39.649200439453, -935.27795410156),
                        ["Gas Station"] = CFrame.new(608.599426, 65.3087997, -267.643066, -0.414288431, -1.04483455e-09, -0.91014564, -1.30518893e-08, 1, 4.79309215e-09, 0.91014564, 1.38648408e-08, -0.41428),
                        ["School"] = CFrame.new(-581.790283, 68.4947281, 331.046448, 0.220051467, -7.56681329e-05, 0.975498199, -3.96428077e-05, 0.999999583, 8.65130132e-05, -0.975498199, -5.77078645e-05, 0.22005),
                        ["Military"] = CFrame.new(92.643799, 122.749977, -860.128784, 0.986730993, 5.09704545e-09, 0.162363499, -9.24942123e-10, 1, -2.57716568e-08, -0.162363499, 2.52795154e-08, 0.986730993),
                        ["Ufo"] = CFrame.new(65.1504517, 138.999954, -691.819031, -0.935115993, -5.9791418e-08, -0.354341775, -3.10840989e-08, 1, -8.67077574e-08, 0.354341775, -7.0067415e-08, -0.935115993),
                        ["Bank"] = CFrame.new(-374.538391, 102.052887, -440.20871, 0.958144963, 9.24065989e-06, -0.286283433, -9.98981818e-07, 1, 2.89345699e-05, 0.286283433, -2.74375216e-05, 0.958144963),
                        ["Gym Top"] = CFrame.new(-76.178093, 56.6998138, -629.940979, -0.9998914, -1.09370752e-07, 0.0147391548, -1.0945012e-07, 1, -4.57786342e-09, -0.0147391548, -6.1905685e-09, -0.9998914),
                        ["Casino"] = CFrame.new(-1048.95093, 110.254997, -154.554016, 0.198458344, 0.0412604436, -0.979240835, -4.06676299e-05, 0.999113858, 0.0420895219, 0.98010987, -0.00831318926, 0.198284075),
                        ["Uphill"] = CFrame.new(485.651947, 112.5, -644.316833, -0.998899043, 1.33881997e-06, 0.0469136797, 8.00526664e-07, 1, -1.14929126e-05, -0.0469136797, -1.14426994e-05, -0.998899043),
                        ["Revolver"] = CFrame.new(-659.053162, 110.748001, -158.224365, 0.146754071, -2.38941595e-08, -0.989172995, -1.60316838e-09, 1, -2.43935396e-08, 0.989172995, 5.16566212e-09, 0.146754071),
                        ["Flank"] = CFrame.new(376.730621, 130.748001, -245.620468, 0.996583343, 5.90310174e-06, -0.0825867951, -1.72590728e-06, 1, 5.06508768e-05, 0.0825867951, -5.03353003e-05, 0.996583343),
                        ["PlayGround"] = CFrame.new(-260.836182, 126.424866, -877.783875, -0.977067351, -1.56508904e-05, -0.212922528, 9.92513264e-07, 1, -7.80593255e-05, 0.212922528, -7.64806027e-05, -0.977067351),
                    }
  
                if CFrameValues[State] then
                    Client.Character.HumanoidRootPart.CFrame = CFrameValues[State]
                end
                end)
            end

            local AutoBuySection = Menu.Container('Misc', 'Buy', 'Right') do

                Menu.ComboBox('Misc', 'Buy', 'Gun', 'LMG', ItemTableValues.Guns, function(self)
                    Settings.Misc.Auto_Buy.Gun = self
                end)
                Menu.Button('Misc', 'Buy', 'Buy Gun', function()
                    AutoBuy(ItemTable.Guns[Settings.Misc.Auto_Buy.Gun], false, 2)
                end)

                Menu.Button('Misc', 'Buy', 'Buy Ammo', function()
                    AutoBuy(ItemTable.Ammo[Settings.Misc.Auto_Buy.Gun], true, 1)
                end)

            end
  
            local MTSection6 = Menu.Container("Misc", "Stuff", "Left") do
                Menu.CheckBox("Misc", "Stuff", "Auto Grab Cash", false, function(a)
                    Settings.Misc.Cash.AutoPick = a
                end)
                Menu.CheckBox("Misc", "Stuff", "Auto Drop Cash", false, function(a)
                    Settings.Misc.Cash.AutoDrop = a
                end)
                Menu.Slider("Misc", "Stuff", "Auto Drop Amount", 0, 10, 6, '%', 1, function(a)
                    Settings.Misc.Cash.Amount = a * 1000
                end)
                Menu.CheckBox("Misc", "Stuff", "Auto Stomp", false, function(a)
                    Settings.Misc.Random.AutoStomp = a
                end)
                
                Menu.CheckBox("Misc", "Stuff", "No Recoil", false, function(a)
                  Settings.Misc.Random.NoRecoil = a
              end)
  
              Menu.CheckBox("Misc", "Stuff", "No Slow", false, function(a)
                  Settings.Misc.Random.NoSlow = a
              end)
                Menu.CheckBox("Misc", "Stuff", "Anti Bag", false, function(a)
                    Settings.Misc.Random.AntiBag = a
                end)
                Menu.CheckBox("Misc", "Stuff", "Bunny Hop", false, function(a)
                    getgenv().Bhop = a
                    while getgenv().Bhop do
                        task.wait()
                        if Client.Character.Humanoid:GetState() ~= Enum.HumanoidStateType.Freefall then
                            Client.Character.Humanoid:ChangeState("Jumping")
                        end
                    end
                end)
            end

            local MTSection9 = Menu.Container("Misc", "Desync", "Left") do
                Menu.CheckBox("Misc", "Desync", "Invisible Desync", false, function(a)

                    for i = 1, 2 do 
                        Script.Functions.Update_Desync(a)
                        task.wait(.1)
                    end

                end)

                Menu.CheckBox("Misc", "Desync", "CFrame Desync", false, function(a)
                    Settings['Destroy Cheaters'].Enabled = a
                    DestroyCheaters()
                end)

                Menu.Hotkey("Misc", "Desync", "Keybind", Settings['Destroy Cheaters'].Keybind, function(a)
                    Settings['Destroy Cheaters'].Keybind = a
                    DestroyCheaters()
                end)

            end
        end
  
        local VisualsTab = Menu.Tab("Visuals") do
  
            local TLHightlightSection = Menu.Container("Visuals", "ESP", "Left") do
                Menu.CheckBox("Visuals", "ESP", "Enabled", false, function(a)
                    getgenv().esp.Enabled = a
                end)
                Menu.CheckBox("Visuals", "ESP", "Box", true, function(a)
                    getgenv().esp.BoxEnabled = a
                end)
                Menu.ColorPicker("Visuals", "ESP", "Box Color", Color3.fromRGB(255, 255, 255), 0, function(a)
                    getgenv().esp.BoxColor = a
                end)
                Menu.ColorPicker("Visuals", "ESP", "Text Color", Color3.fromRGB(255, 255, 255), 0, function(a)
                    getgenv().esp.TextColor = a
                end)
                Menu.CheckBox("Visuals", "ESP", "Name", true, function(a)
                    getgenv().esp.TextLayout.name.enabled = a
                end)
                
                Menu.CheckBox("Visuals", "ESP", "Health", true, function(a)
                    getgenv().esp.TextLayout.health.enabled = a
                end)
                Menu.CheckBox("Visuals", "ESP", "HealthBar", true, function(a)
                    getgenv().esp.BarLayout.health.enabled = a
                end)
                Menu.ColorPicker("Visuals", "ESP", "LowerHealthColor", Color3.fromRGB(255, 255, 255), 0, function(a)
                    getgenv().esp.BarLayout.health.color_empty = a
                end)
                Menu.ColorPicker("Visuals", "ESP", "HigherHealthColor", Color3.fromRGB(255, 102, 204), 0, function(a)
                    getgenv().esp.BarLayout.health.color_full = a
                end)
                Menu.CheckBox("Visuals", "ESP", "Armor", true, function(a)
                    getgenv().esp.TextLayout.armor.enabled = a
                end)
                Menu.CheckBox("Visuals", "ESP", "ArmorBar", true, function(a)
                    getgenv().esp.BarLayout.armor.enabled = a
                end)
                Menu.ColorPicker("Visuals", "ESP", "LowerArmorColor", Color3.fromRGB(255, 102, 204), 0, function(a)
                    getgenv().esp.BarLayout.armor.color_empty = a
                end)
                Menu.ColorPicker("Visuals", "ESP", "HigherArmorColor", Color3.fromRGB(255, 102, 204), 0, function(a)
                    getgenv().esp.BarLayout.armor.color_full = a
                end)
                Menu.CheckBox("Visuals", "ESP", "Distance", true, function(a)
                    getgenv().esp.TextLayout.distance.enabled = a
                end)
                Menu.CheckBox("Visuals", "ESP", "Tool", true, function(a)
                    getgenv().esp.TextLayout.tool.enabled = a
                end)
                Menu.CheckBox("Visuals", "ESP", "Skeletons", false, function(a)
                    getgenv().esp.SkeletonEnabled = a
                end)

                Menu.CheckBox("Visuals", "ESP", "Chams", false, function(a)
                    getgenv().esp.ChamsEnabled = a
                end)
                Menu.ColorPicker("Visuals", "ESP", "ChamsInnerColor", Color3.fromRGB(255, 102, 204), 0, function(a)
                    getgenv().esp.ChamsInnerColor = a
                end)
                Menu.ColorPicker("Visuals", "ESP", "ChamsOuterColor", Color3.fromRGB(255, 255, 255), 0, function(a)
                    getgenv().esp.ChamsOuterColor = a
                end)
            end
  
            local Section6 = Menu.Container("Visuals", "World Customization", "Left") do
                Menu.CheckBox("Visuals", "World Customization", "Enabled", false, function(self)
                    Settings.Visuals.World_Customization.Enabled = self
                end)
                Menu.ColorPicker("Visuals", "World Customization", "World Customization", MainColor, 0, function(self)
                    task.spawn(function()
                        while task.wait() do
                            if Settings.Visuals.World_Customization.Enabled then
                                Lighting.ColorCorrection.TintColor = self
                            else
                                Lighting.ColorCorrection.TintColor = Color3.fromRGB(255, 255, 255)
                            end
                        end
                    end)
                end)

                Menu.CheckBox("Visuals", "World Customization", "UI", false, function(self)
                    Settings.Visuals.World_Customization.Bars = self
                end)
                Menu.ColorPicker("Visuals", "World Customization", "World Customization", MainColor, 0, function(self)
                    Settings.Visuals.World_Customization.BarsColor = self
                end)
            end
  
            local Section7 = Menu.Container("Visuals", "Crosshair", "Right") do
              Menu.CheckBox("Visuals", "Crosshair", "Enabled", false, function(a)
                  getgenv().crosshair.enabled = a
              end)
              Menu.ColorPicker("Visuals", "Crosshair", "Color", MainColor, 0, function(a)
                  getgenv().crosshair.color = a
              end)
              Menu.ComboBox("Visuals", "Crosshair", "Position", "mouse", {"mouse", "center"}, function(a)
                  getgenv().crosshair.mode = a
              end)
  
              Menu.Slider('Visuals', 'Crosshair', 'Width', 1, 5, 2.5, '', 1, function(self)
                  getgenv().crosshair.width = self
              end)
              Menu.Slider('Visuals', 'Crosshair', 'Length', 1, 50, 10, '', 0, function(self)
                  getgenv().crosshair.length = self
              end)
              Menu.Slider('Visuals', 'Crosshair', 'Radius', 0, 20, 11, '', 1, function(self)
                  getgenv().crosshair.radius = self
              end)
  
              Menu.CheckBox('Visuals', 'Crosshair', 'Spin', getgenv().crosshair.spin, function(self)
                  getgenv().crosshair.spin = self
              end)
              Menu.Slider('Visuals', 'Crosshair', 'Spin Speed', 1, 340, 150, '', 0, function(self)
                  getgenv().crosshair.spin_speed = self
              end)
  
              Menu.CheckBox('Visuals', 'Crosshair', 'Resize', getgenv().crosshair.resize, function(self)
                  getgenv().crosshair.resize = self
              end)
              Menu.Slider('Visuals', 'Crosshair', 'Resize Speed', 1, 22, 5, '', 0, function(self)
                  getgenv().crosshair.resize_speed = self
              end)
          end
  
            local TLHightlightSection = Menu.Container("Visuals", "HighLight", "Right") do
                Menu.CheckBox("Visuals", "HighLight", "Enabled", true, function(a)
                    Settings.Combat.Visuals.HighLight.Enabled = a
                end)
                Menu.ColorPicker("Visuals", "HighLight", "Fill Color", MainColor, 0, function(a)
                    Settings.Combat.Visuals.HighLight.FillColor = a
                end)
                Menu.ColorPicker("Visuals", "HighLight", "OutLine Color", Color3.fromRGB(255, 255, 255), 0, function(a)
                    Settings.Combat.Visuals.HighLight.OutLineColor = a
                end)
            end
  
            local TLBackTrackSection = Menu.Container("Visuals", "BackTrack", "Right") do
                Menu.CheckBox("Visuals", "BackTrack", "Enabled", true, function(a)
                    Settings.Combat.Visuals.BackTrack.Enabled = a
                end)
                Menu.Slider("Visuals", "BackTrack", "Transparency", 0, 1, 0, '', 1, function(a)
                    Settings.Combat.Visuals.BackTrack.Transparency = a
                end)
                Menu.Slider("Visuals", "BackTrack", "Delay", 0, 5, 0.1, '', 1, function(a)
                    Settings.Combat.Visuals.BackTrack.Delay = a
                end)
                Menu.ColorPicker("Visuals", "BackTrack", "Color", MainColor, 0, function(a)
                    Settings.Combat.Visuals.BackTrack.Color = a
                end)
                Menu.ComboBox("Visuals", "BackTrack", "Material", "ForceField", {"ForceField", "Neon", "Plastic"}, function(a)
                    Settings.Combat.Visuals.BackTrack.Material = a
                end)
            end
  
            local TLLineSection = Menu.Container("Visuals", "Line", "Right") do
                Menu.CheckBox("Visuals", "Line", "Enabled", true, function(a)
                    Settings.Combat.Visuals.Line.Visible = a
                end)
                Menu.CheckBox("Visuals", "Line", "Circle", true, function(a)
                    Settings.Combat.Visuals.Line.Circle = a
                end)
                Menu.Slider("Visuals", "Line", "Transparency", 0, 1, 0, '', 1, function(a)
                    Settings.Combat.Visuals.Line.Transparency = a
                end)
                Menu.Slider("Visuals", "Line", "Thickness", 0, 5, 0.5, '', 1, function(a)
                    Settings.Combat.Visuals.Line.Thickness = a
                end)
                Menu.ColorPicker("Visuals", "Line", "Color", MainColor, 0, function(a)
                    Settings.Combat.Visuals.Line.Color = a
                end)
            end
  
            local Section8 = Menu.Container("Visuals", "Bullet Tracers", "Right") do
                Menu.CheckBox("Visuals", "Bullet Tracers", "Enabled", false, function(self)
                    Settings.Visuals.Bullet_Trails.Enabled = self
                end)
  
                Menu.ComboBox("Visuals", "Bullet Tracers", "Texture", "Normal", {"Normal", "Fog"}, function(self)
                    Settings.Visuals.Bullet_Trails.Texture = self
                end)
  
                Menu.ColorPicker("Visuals", "Bullet Tracers", "Color", MainColor, 0, function(self)
                    Settings.Visuals.Bullet_Trails.Color = ColorSequence.new({ColorSequenceKeypoint.new(0, self), ColorSequenceKeypoint.new(1, self)})
                end)
            end
  
            local Section8 = Menu.Container("Visuals", "Aim Viewer", "Right") do
              Menu.CheckBox("Visuals", "Aim Viewer", "Enabled", false, function(self)
                AntiAimViewer_Enabled = self
              end)
  
              Menu.ColorPicker("Visuals", "Aim Viewer", "Color", MainColor, 0, function(self)
                AntiAimViewer_Color = self
              end)
  
              Menu.TextBox("Visuals", "Aim Viewer", "Target", 'Username', function(self)
                AntiAimViewer_Target = findPlayerByUsername(self)
              end)
  
              Menu.CheckBox("Visuals", "Aim Viewer", "HighLight", false, function(self)
                AntiAimViewer_HighLight = self
              end)
  
              Menu.ColorPicker("Visuals", "Aim Viewer", "Color", Color3.fromRGB(255, 255, 255), 0, function(self)
                AntiAimViewer_HighLight_OutLineColor = self
              end)
  
              Menu.ColorPicker("Visuals", "Aim Viewer", "Color", MainColor, 0, function(self)
                AntiAimViewer_HighLight_FillColor = self
              end)
          end
  
          local Section7 = Menu.Container("Visuals", "Client Chams", "Left") do
            Menu.CheckBox("Visuals", "Client Chams", "Weapon Enabled", false, function(self)
                Settings.Visuals.Weapon_Chams.Enabled = self
            end)
            Menu.ColorPicker("Visuals", "Client Chams", "Weapon Color", MainColor, 0, function(self)
                Settings.Visuals.Weapon_Chams.Color = self
            end)
            Menu.ComboBox("Visuals", "Client Chams", "Weapon Cham Type", "Plastic", {"Plastic", "Neon"}, function(self)
                if self == 'Plastic' then
                    Settings.Visuals.Weapon_Chams.Material = Enum.Material.SmoothPlastic
                elseif self == 'Neon' then
                    Settings.Visuals.Weapon_Chams.Material = Enum.Material.Neon
                end
            end)

            Menu.CheckBox("Visuals", "Client Chams", "Client Enabled", false, function(self)
                Settings.Visuals.Character_Chams.Enabled = self
            end)
            Menu.ColorPicker("Visuals", "Client Chams", "Client Color", MainColor, 0, function(self)
                Settings.Visuals.Character_Chams.Color = self
            end)
            Menu.ComboBox("Visuals", "Client Chams", "Client Cham Type", "Force Field", {"Force Field", "Neon"}, function(self)
                if self == 'Force Field' then
                    Settings.Visuals.Character_Chams.Material = Enum.Material.ForceField
                elseif self == 'Neon' then
                    Settings.Visuals.Character_Chams.Material = Enum.Material.Neon
                end
            end)

            Menu.CheckBox("Visuals", "Client Chams", "Trail Enabled", false, function(self)
                ToggleTrail(self)
            end)
            Menu.ColorPicker("Visuals", "Client Chams", "Trail Color", MainColor, 0, function(self)
                Settings.Visuals.Character_Chams.Trail_Color = self
            end)
            Menu.Slider("Visuals", "Client Chams", "Trail Life", 1, 10, 3, '', 0, function(a)
                Settings.Combat.Visuals.Line.Trail_Life = a
            end)
        end
  
        end
  
        local ConfigsTab = Menu.Tab("Configuration") do
  
            local MenuSection = Menu.Container("Configuration", "Menu", "Left") do
                Menu.Hotkey('Configuration', 'Menu', 'Menu key', Settings.Configs.Menu.Keybind, function(a)
                    Settings.Configs.Menu.Keybind = a
                    ContextAction:BindAction('menuToggle', MenuToggle, true, a)
                end)

                Menu.ColorPicker("Configuration", "Menu", "Color", MainColor, 0, function(self)
                    MainColor = self
                    Menu.Accent = self
                end)
        
                Menu.CheckBox('Configuration', 'Menu', 'Indicators', false, function(Boolean)
                    Menu.Indicators:SetVisible(Boolean)
                end)
        
                Menu.CheckBox('Configuration', 'Menu', 'Keybinds', false, function(Boolean)
                    Menu.Keybinds:SetVisible(Boolean)
                end)
        
                Menu.Button('Configuration', 'Menu', 'Rejoin', function()
                    TeleportPlace(game.PlaceId, game.JobId)
                end)

            end

            local ConfigSection = Menu.Container('Configuration', 'Configs', 'Right') do
                Menu.TextBox('Configuration', 'Configs', 'Config Name', '')

                Menu.ListBox('Configuration', 'Configs', 'Config List', false, {}, function()

                end)

                Menu.Button('Configuration', 'Configs', 'Create', function()
                    
                end)

                Menu.Button('Configuration', 'Configs', 'Save', function()
                    
                end)

                Menu.Button('Configuration', 'Configs', 'Load', function()
                    
                end)
            end
            
        end
    end

  local function UpdateIndicators()

    --Menu.Keybinds.List['Enabled']:Update(Settings['Main']['Enabled'] and "On" or "Off")

    if enabled and Target then
        Menu.Indicators.List['Target']:Update(Target.Name)

        Menu.Indicators.List['Target Health']:SetVisible(true)
        Menu.Indicators.List['Target Armor']:SetVisible(true)

        Menu.Indicators.List['Knocked Out']:SetVisible(true)
        Menu.Indicators.List['Anti Aiming']:SetVisible(true)
    else
        Menu.Indicators.List['Target']:Update('nil')
        Menu.Indicators.List['Target Health']:SetVisible(false)
        Menu.Indicators.List['Target Armor']:SetVisible(false)

        Menu.Indicators.List['Knocked Out']:SetVisible(false)
        Menu.Indicators.List['Anti Aiming']:SetVisible(false)

        Menu.Indicators.List['Target Ammo']:SetVisible(false)
    end

    if enabled and Target then
        local Character = Target.Character

        if Character then
            local RootPart = Character and Character:FindFirstChild('HumanoidRootPart')
            local Humanoid = Character and Character:FindFirstChild('Humanoid')

            local BodyEffects = Character and Character:FindFirstChild('BodyEffects')
            local Armor = BodyEffects and BodyEffects:FindFirstChild('Armor')
            local KnockedOut = BodyEffects and BodyEffects:FindFirstChild('K.O')

            Menu.Indicators.List['Target Health']:Update(math.floor(Humanoid.Health), 0, 100)
            Menu.Indicators.List['Target Armor']:Update(Armor.Value, 0, 200)

            if KnockedOut and KnockedOut.Value then
                Menu.Indicators.List['Knocked Out']:Update('[True]')
            else
                Menu.Indicators.List['Knocked Out']:Update('[False]')
            end

            if RootPart and (RootPart.AssemblyLinearVelocity.X > 40 or RootPart.AssemblyLinearVelocity.Y > 40 or RootPart.AssemblyLinearVelocity.Z > 40 or RootPart.AssemblyLinearVelocity.X < -40 or RootPart.AssemblyLinearVelocity.Y < -40 or RootPart.AssemblyLinearVelocity.Z < -40) then
                Menu.Indicators.List['Anti Aiming']:Update('[True]')
            else
                Menu.Indicators.List['Anti Aiming']:Update('[False]')
            end

            for i, v in pairs(Character:GetChildren()) do
                if v:IsA('Tool') and (v:FindFirstChild('Ammo') and v:FindFirstChild('MaxAmmo')) then
                    Menu.Indicators.List['Target Ammo']:SetVisible(true)

                    local Ammo = v.Ammo.Value
                    local MaxAmmo = v.MaxAmmo.Value

                    task.wait()
                    Menu.Indicators.List['Target Ammo']:Update(Ammo, 0, MaxAmmo)
                else
                    Menu.Indicators.List['Target Ammo']:SetVisible(false)
                end
            end

        end

    end
end
  
  
  ---------------------------------------------------------------------------------- scripts
  
  do --// notification library
    do --// Notifications 
        local NotificationContainer = Instance.new("ScreenGui", gethui());
        do  --// Functions
            function Notifications:UpdateNotifications()
                local i = 0
                for v in next, Notifications do
                    if v.Holder then
                        local tween = Utility:Tween(v.Holder, TweenInfo.new(0.8, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {Position = UDim2.new(0, 20, 0, 75 + (i * 25))})
                        i = i + 1
                    end
                end
            end;
  
            function Notifications:UpdateNotifications2(Item)
                for i,v in pairs(Item) do
                    if typeof(v) == "Instance" then
                        task.spawn(function()
                            local tween = Utility:Tween(v, TweenInfo.new(1, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {BackgroundTransparency = 1});
  
                            tween.Completed:Connect(function()
                                if v.Name == "Holder" then
                                    v:Destroy();
                                end
                            end)
                        end);
                        if v.ClassName == "TextLabel" then
                            local tween = Utility:Tween(v, TweenInfo.new(1, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {TextTransparency = 1})
                        end
                    end
                end
            end
  
            function Notifications:New(Text, Time, Color)
                Time = Time or 2;
                Color = Color or Color3.fromRGB(100, 95, 192);
                Text = Text or "No text provided? retard? "..tostring(math.random());
  
                local Notification = {};
  
                local Holder = Instance.new("Frame")
                Holder.Position = UDim2.new(0, -30, 0, 75);
                Holder.Size = UDim2.new(0, 0, 0, 23);
                Holder.BackgroundTransparency = 0;
                Holder.Parent = NotificationContainer;
                Holder.BackgroundColor3 = Color3.fromRGB(37, 37, 37);
                Holder.BorderSizePixel = 1
                Holder.BorderColor3 = Color3.fromRGB(0, 0, 0)
                Notification.Holder = Holder;
  
                local Background = Instance.new("Frame");
                Background.Parent = Holder;
                Background.Size = UDim2.new(1, -4, 1, -4);
                Background.BackgroundColor3 = Color3.fromRGB(17, 17, 17);
                Background.Position = UDim2.new(0, 2, 0, 2);
                Background.BorderSizePixel = 1
                Background.BorderColor3 = Color3.fromRGB(0, 0, 0)
                Notification.Background = Background;
  
                local AccentBar = Instance.new("Frame");
                AccentBar.Size = UDim2.new(0, 1, 1, 0);
                AccentBar.Parent = Background;
                AccentBar.BackgroundColor3 = Color;
                AccentBar.Position = UDim2.new(0, 0, 0, 0);
                AccentBar.BorderSizePixel = 0
                Notification.AccentBar = AccentBar;
  
                local AccentBar2 = Instance.new("Frame");
                AccentBar2.Size = UDim2.new(0, 0, 0, 1);
                AccentBar2.Position = UDim2.new(0, 0, 0, 15);
                AccentBar2.Parent = Background;
                AccentBar2.BackgroundColor3 = Color;
                AccentBar2.BorderSizePixel = 0
  
                Notification.AccentBar2 = AccentBar2
                local NotifText = Instance.new("TextLabel");
                NotifText.TextXAlignment = Enum.TextXAlignment.Left;
                NotifText.Position = UDim2.new(0, 3, 0, 0);
                NotifText.Size = UDim2.new(1, 0, 1, 0)
                NotifText.Parent = Background;
                NotifText.Font = Enum.Font.Ubuntu;
                NotifText.TextColor3 = Color3.new(1,1,1);
                NotifText.BackgroundTransparency = 1;
                NotifText.TextSize = 12.00;
                NotifText.Text = Text;
  
                Notification.NotifText = NotifText;
                Notification.Holder.Size = UDim2.new(0, NotifText.TextBounds.X + 10, 0, 19);
  
                AccentBar2.Size = UDim2.new(0, 1, 0, 1)
  
                Notifications[Notification] = true
  
                local Connection
                function Notification:Remove()
                    Notifications[Notification] = nil
                    Notifications:UpdateNotifications();
                end;
                task.spawn(function()
                    Notification.Holder.Size = UDim2.new(0, NotifText.TextBounds.X + 10, 0, 19);
                    Notifications:UpdateNotifications()
                    Notification.AccentBar2:TweenSize(UDim2.new(0, Background.AbsoluteSize.X - 1, 0, 1), Enum.EasingDirection.Out, Enum.EasingStyle.Linear, Time, false);
                    task.wait(Time)
  
                    Notifications:UpdateNotifications2(Notification)
                    task.wait(1.2)
                    Notification:Remove()
                end);
            end;
        end;
    end;
  
    do
        function Utility:Tween(...)
            local NewTween = game:GetService("TweenService"):Create(...)
            NewTween:Play();
            return NewTween;
        end;
    end
  end
  
--// Functions
local function GetCalculatedVelocity(Player)
    local Char = Player.Character
    local Root = Char and Char:FindFirstChild('HumanoidRootPart')
    local Velocity = Vector3.new()

    if (Char and Root) then
        local CurrentPos = Root.Position
        local CurrentTime = tick()

        task.wait(0.00350)

        local NewPos = Root.Position
        local NewTime = tick()

        local FinalTime = NewTime - CurrentTime
        Velocity = (NewPos - CurrentPos) / FinalTime
        CurrentPos = NewPos
        CurrentTime = NewPos
    end

    return Velocity
end

local function UpdateBuiltVelocity()
    if Target then
        BuiltVelocity = GetCalculatedVelocity(Target)
    end
end


local VisibleCheck = function (Part, PartDescendant)
    local Character = Client.Character or Client.CharacterAdded.Wait(Client.CharacterAdded)
    local Origin = Camera.CFrame.Position
    local _, OnScreen = Camera.WorldToViewportPoint(Camera, Part.Position)

    if (OnScreen) then
        local raycastParams = RaycastParams.new()
        raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
        raycastParams.FilterDescendantsInstances = {Character, Camera}

        local Result = Workspace.Raycast(Workspace, Origin, Part.Position - Origin, raycastParams)

        if (Result) then
            local PartHit = Result.Instance
            local Visible = (not PartHit or Instance.new("Part").IsDescendantOf(PartHit, PartDescendant))

            return Visible
        end
    end
    return false
end

local function GetClosestPlayerFOV()
    local Player = nil
    local Distance = FoVCircle.Radius

    for i, v in pairs(Players:GetPlayers()) do
        if (v == Client) then continue end

        local Character = v.Character
        local RootPart  = Character and Character:FindFirstChild('HumanoidRootPart')


        if Settings.Combat.Checks.WallCheck then
            if Camera:WorldToScreenPoint(v.Character[Settings.Combat.TargetLock.HitParts].Position) and VisibleCheck(v.Character[Settings.Combat.TargetLock.HitParts], v.Character) then
                if (Character and RootPart) then
                    local Pos = Workspace.CurrentCamera:WorldToViewportPoint(RootPart.Position)
                    local Mag = (Vector2.new(Pos.x, Pos.y) - UserInputService:GetMouseLocation()).magnitude

                    if (Mag < Distance) then
                        Distance = Mag
                        Player = v
                    end
                end
            end
        else
            if (Character and RootPart) then
                local Pos = Workspace.CurrentCamera:WorldToViewportPoint(RootPart.Position)
                local Mag = (Vector2.new(Pos.x, Pos.y) - UserInputService:GetMouseLocation()).magnitude

                if (Mag < Distance) then
                    Distance = Mag
                    Player = v
                end
            end
        end
    end

    return Player
end

local function KeybindHandler(Index, Texting)

    if not Texting and Index.KeyCode == Settings['Destroy Cheaters'].Keybind then
        DestroyCheaters()
        Notifications:New('CFrame Desync: ' .. tostring(Settings['Destroy Cheaters'].Enabled), 1.5, MainColor)
    end

    if not Texting and Index.KeyCode == Settings.Combat.TargetLock.KeyBind and Settings.Combat.TargetLock.Enabled then
        if Keybind and enabled then
            Keybind = false
            enabled = false
            if Target ~= nil then
                Target = nil
                ENABLEDHIGHTLIGHTCHECK = false
                if Settings.Visuals.Notifications then
                    Notifications:New('Unlocked... haha!', 1.5, MainColor)
                end
                if Settings.Combat.Stuff.Spectate then
                    game.Workspace.CurrentCamera.CameraSubject = Client.Character
                end
            end
        else
            Keybind = true
            enabled = true
            Target  = GetClosestPlayerFOV();
            if Settings.Visuals.Notifications then
                Notifications:New('Target : ' .. tostring(Target), 1.5, MainColor)
            end
            ENABLEDHIGHTLIGHTCHECK = true
            if Settings.Combat.Stuff.Spectate and Target then
                game.Workspace.CurrentCamera.CameraSubject = Target.Character
            end
            task.spawn(function ()
                while enabled do
                    wait()
                    BacktrackPlayer(Target)
                end
            end)
        end
    end
end

local function ChattedAdmin(Chat)
    if Client and Client.Character then
        local PrefixFound = Chat:sub(1, 1) == "$"

        if (PrefixFound) then
            local SplitChat = Chat:split(' ')
            if (SplitChat[1]:lower():find('target')) then 
                enabled = true
                Target = FindPlayer(SplitChat[2])

                if Settings.Visuals.Notifications then
                    Notifications:New('Target : ' .. tostring(Target), 1.5, MainColor)
                end

                ENABLEDHIGHTLIGHTCHECK = true

                if Settings.Combat.Stuff.Spectate and Target then
                    game.Workspace.CurrentCamera.CameraSubject = Target.Character
                end

                task.spawn(function ()
                    while enabled do
                        wait()
                        BacktrackPlayer(Target)
                    end
                end)
                
            elseif (SplitChat[1]:lower():find('goto')) then
                local GotoPlayer = FindPlayer(SplitChat[2])
    
                if (GotoPlayer) then
                    Client.Character.HumanoidRootPart.CFrame = GotoPlayer.Character.HumanoidRootPart.CFrame
                end
            end
        end
    end
end

local function PostSimulation(Delta)
    if Settings['Destroy Cheaters'].Enabled then
        local LocalCharacter = Client.Character
        local LocalRootPart = Client and LocalCharacter:FindFirstChild("HumanoidRootPart")

        if not LocalRootPart then return end

        Desync.ClientLocation = LocalRootPart.CFrame

        if (Desync.cframe) then 
            LocalRootPart.CFrame = Desync.cframe
        end

        RunService.PreRender:Wait()

        LocalRootPart.CFrame = Desync.ClientLocation
        Desync.ClientLocation = nil
    end
end

RunService.PostSimulation:Connect(PostSimulation);

Client.Chatted:Connect(ChattedAdmin)

function UpdateFov() -- connect to heartbeat loop
    FoVCircle.Position = Vector2.new(Mouse.X, Mouse.Y + GetGuiInset(GuiService).Y)
    FoVCircle.Visible = false
end


--// Loops
task.spawn(function() while task.wait() do UpdateBuiltVelocity() end end)

--// Hooking Target Aimbot 
Hooks = function()
    if Settings.Combat.TargetLock.Enabled and Target and Target.Character and List[game.PlaceId] then
        local Position
        local TargetCharacter = Target.Character
        if (Settings.Combat.Checks.Resolver) then
            Position = TargetCharacter[Settings.Combat.TargetLock.HitParts].Position + (BuiltVelocity * Vector3.new(Settings.Combat.TargetLock.Prediction, Settings.Combat.TargetLock.Prediction, Settings.Combat.TargetLock.Prediction))
        else
            Position = TargetCharacter[Settings.Combat.TargetLock.HitParts].Position + (TargetCharacter[Settings.Combat.TargetLock.HitParts].Velocity * Vector3.new(Settings.Combat.TargetLock.Prediction, Settings.Combat.TargetLock.Prediction, Settings.Combat.TargetLock.Prediction))
        end
        game.ReplicatedStorage[List[game.PlaceId][3]]:FireServer(List[game.PlaceId][2], Position)
    end
end

connection = function(Character)
    Character.ChildAdded:Connect(function(Tool)
        if Tool:IsA('Tool') then
            Tool.Activated:Connect(Hooks)
        end
    end)
end

game.Players.LocalPlayer.CharacterAdded:Connect(connection)
connection(game.Players.LocalPlayer.Character)
 
  
        -- FIRE VISUALS 
  
        Script.Drawing.Line = Drawing.new("Line")
        Script.Drawing.Line.From = Vector2.new(0, 0)
        Script.Drawing.Line.To = Vector2.new(0, 0)
        Script.Drawing.Line.Visible = Settings.Combat.Visuals.Line.Visible
        Script.Drawing.Line.Thickness = Settings.Combat.Visuals.Line.Thickness
        Script.Drawing.Line.Color = Settings.Combat.Visuals.Line.Color
        Script.Drawing.Line.Transparency = Settings.Combat.Visuals.Line.Transparency
  
  
  
  
        -- backtrack
        function BacktrackPlayer(player)
            if Settings.Combat.Visuals.BackTrack.Enabled and Settings.Combat.TargetLock.Enabled == true and enabled and Target and Target.Character and Target.Character:FindFirstChild("HumanoidRootPart") then
                player.Character.Archivable = true
                local Cloned = player.Character:Clone()
                Cloned.Name = "Player Clone"
                for _, v in ipairs(Cloned:GetChildren()) do
                    if v:IsA("BasePart") and v.Name ~= "HumanoidRootPart" then
                        v.CanCollide = false
                        v.Anchored = true
                        v.Material = Settings.Combat.Visuals.BackTrack.Material
                        v.Color = Settings.Combat.Visuals.BackTrack.Color
                        v.Transparency = Settings.Combat.Visuals.BackTrack.Transparency
                    else
                        v:Destroy()
                    end
                end
                if Cloned:FindFirstChild("Head") and Cloned:FindFirstChild("Head"):FindFirstChild("face") then
                    Cloned.Head.face:Destroy()
                end
                Cloned.Parent = game.Workspace
                wait(Settings.Combat.Visuals.BackTrack.Delay)
                Cloned:Destroy()
            end
        end
  
  
        -- look at
  
  
  
    do -- prediction breaker
  
        if getgenv().OldKeyConnection then
            getgenv().OldKeyConnection:Disconnect()
            getgenv().OldKeyConnection = nil
        end
        getgenv().OldKeyConnection =
        UserInputService.InputBegan:Connect(
            function(input, isTyping)
                if input.KeyCode == Settings.Misc.PredictionDisabler.KeyBind and isTyping == false and Settings.Misc.PredictionDisabler.Enabled == true then
                    if Antilockhahga == false then
                        Antilockhahga = true
                        Menu.Keybinds.List['Prediction Breaker']:Update(true and "On" or "Off")
                        if  Settings.Misc.PredictionDisabler.Notifications == true then
                            Notifications:New('Prediction Breaker : TRUE.', 1.5, MainColor)
                        end
                    else
                        Antilockhahga = false
                        Menu.Keybinds.List['Prediction Breaker']:Update(false and "On" or "Off")
                        if  Settings.Misc.PredictionDisabler.Notifications == true then
                            Notifications:New('Prediction Breaker : FALSE.', 1.5, MainColor)
                        end
                    end
                end
            end
        )
        if getgenv().OldStepConnection then
            getgenv().OldStepConnection:Disconnect()
            getgenv().OldStepConnection = nil
        end
        getgenv().OldStepConnection = RunService.Stepped:Connect(function(_, Delta)
                local success, err = pcall(function()
                        if Settings.Misc.PredictionDisabler.Enabled ~= true then
                        else
                        local char = game.Players.LocalPlayer.Character
                        if char and char:FindFirstChildOfClass("Humanoid") and char:FindFirstChildOfClass("Humanoid").RootPart and Antilockhahga == true then
                            local hum = char:FindFirstChildOfClass("Humanoid")
                            if Settings.Misc.PredictionDisabler.AutoWalkSpeed then
                                Settings.Misc.PredictionDisabler.WalkSpeed = hum.WalkSpeed
                            end
                            local root = hum.RootPart
                            root.Velocity = Vector3.new(hum.MoveDirection.x, root.Velocity.y, hum.MoveDirection.z)
                            root.CFrame = root.CFrame + ((hum.MoveDirection * Delta) * (Settings.Misc.PredictionDisabler.WalkSpeed * 0.9))
                            for _, Anim in next, hum:GetPlayingAnimationTracks() do
                                local Anim3 = nil
                                local Anim2 = Anim
                                if Anim and Anim.Animation and Anim.Animation.Parent then
                                    Anim3 = Anim.Animation.Parent
                                end
                                if
                                    Anim3 and Anim3.Parent and Anim3.Parent.Name == "Animate" and
                                        (string.find(Anim2.Animation.Name:lower(), "run") or
                                            string.find(Anim2.Animation.Name:lower(), "walk"))
                                then
                                    Anim2:AdjustSpeed(Settings.Misc.PredictionDisabler.WalkSpeed / Settings.Misc.PredictionDisabler.AnimationSpeed)
                                end
                            end
                        end
                    end
                    end
                )
                if err and Settings.Misc.PredictionDisabler.Errors and Settings.Misc.PredictionDisabler.Notifications then
  
                    Notifications:New('Current AntiLock Speed: <b>' .. tostring(Settings.Misc.PredictionDisabler.WalkSpeed) .. '</b>', 1.5, MainColor)
  
                    Antilockhahga = false
  
  
                    if getgenv().OldStepConnection then
                        getgenv().OldStepConnection:Disconnect()
                        getgenv().OldStepConnection = nil
                    end
  
                    if getgenv().OldKeyConnection then
                        getgenv().OldKeyConnection:Disconnect()
                        getgenv().OldKeyConnection = nil
                    end
                end
            end
        )
  
    end
  
    local function GetRandomCFrame(Boolean, Min, Max)
      if Boolean then
          return CFrame.new(math.random(Min, Max), math.random(0, 5), math.random(Min, Max))
      else
          return CFrame.new(-math.random(Min, Max), math.random(0, 5), -math.random(Min, Max))
      end
  end

  function Utility:GetPlayers()
    return Players:GetPlayers()
  end

  function TeleportPlace(PlaceId, JobId)
    if JobId == game.JobId and #Utility:GetPlayers() <= 1 then
        Client:Kick("Misery: Current Server has 0 players, Rejoining.")
        --
        Wait()
        --
        TeleportService:Teleport(PlaceId, Client)
    else
        TeleportService:TeleportToPlaceInstance(PlaceId, JobId, Client)
    end
end
  
  local function VisualzeMovement()
      local Character = Client and (Client.Character or Client.CharacterAdded:Wait())
      local RootPart = Character and Character.HumanoidRootPart
  
      local Ball = Instance.new('Part') do
          Ball.Anchored = true
          Ball.Size = Vector3.new(0.5, 0.5, 0.5)
          Ball.Shape = Enum.PartType.Ball
          Ball.Color = MainColor
          Ball.Material = Enum.Material.ForceField
          Ball.Parent = Workspace
          Ball.CFrame = RootPart.CFrame
          Ball.CanCollide = false
      end;
  
      Debris:AddItem(Ball, 2)
  end
  
  do-- // Target Strafe
      angle_Y = 0
      
      RunService.Stepped:Connect(function (param,FPS)
          local Random = math.random(1, 6)
          local Gun = GetTool()
  
          if enabled and Gun and Target and Target.Character and Settings.Misc.TargetStrafe.Enabled == true and Settings.Misc.TargetStrafe.Method == 'Strafe' then
              if Settings.Misc.TargetStrafe.Visualize_Circle then
                  nigganiggaXD.CFrame = Target.Character.HumanoidRootPart.CFrame
  
                  spawn(function()
                      nigganiggaXD.Size = Vector3.new(Settings.Misc.TargetStrafe.Distance * 0.7, 0.01, Settings.Misc.TargetStrafe.Distance * 0.7)
                      nigganiggaXD.Color = Settings.Misc.TargetStrafe.Color
                  end)
                  
                  spawn(function ()
                      if Settings.Misc.TargetStrafe.Visualize_Circle == false or Settings.Misc.TargetStrafe.Enabled == false then
                          nigganiggaXD.CFrame = CFrame.new(0,9999,0)
                      end
                  end)
  
              end
          else
              nigganiggaXD.CFrame = CFrame.new(0,9999,0)
          end
  
          if Gun and Settings.Misc.TargetStrafe.Enabled and Settings.Misc.TargetStrafe.Method == 'Strafe' then
            if (Target.Character.HumanoidRootPart.CFrame.x > 5000 or Target.Character.HumanoidRootPart.CFrame.y > 5000 or Target.Character.HumanoidRootPart.CFrame.z > 5000 or Target.Character.HumanoidRootPart.CFrame.x < -5000 or Target.Character.HumanoidRootPart.CFrame.y < -5000 or Target.Character.HumanoidRootPart.CFrame.z < -5000) then return end 

              if enabled then
                  if Settings.Combat.Stuff.LookAt == true then
                      Settings.Combat.Stuff.LookAt = false
                      wait()
                      Settings.Combat.Stuff.LookAt = true
                  end
  
                  angle_Y = angle_Y + FPS / Settings.Misc.TargetStrafe.Speed % 1
                  Client.Character.HumanoidRootPart.CFrame = CFrame.new(Target.Character.HumanoidRootPart.Position) * CFrame.Angles(0, 2 * math.pi * angle_Y, 0) * CFrame.new(0, Settings.Misc.TargetStrafe.Height, Settings.Misc.TargetStrafe.Distance)
              end
          elseif Gun and Settings.Misc.TargetStrafe.Enabled and Settings.Misc.TargetStrafe.Method == 'Randomize' and enabled then
            if (Target.Character.HumanoidRootPart.CFrame.x > 5000 or Target.Character.HumanoidRootPart.CFrame.y > 5000 or Target.Character.HumanoidRootPart.CFrame.z > 5000 or Target.Character.HumanoidRootPart.CFrame.x < -5000 or Target.Character.HumanoidRootPart.CFrame.y < -5000 or Target.Character.HumanoidRootPart.CFrame.z < -5000) then return end 

              if Random <= 3 then
                  Client.Character.HumanoidRootPart.CFrame = Target.Character.HumanoidRootPart.CFrame * GetRandomCFrame(true, Settings.Misc.TargetStrafe.RandomizeMin, Settings.Misc.TargetStrafe.RandomizeMax)
                  if Settings.Misc.TargetStrafe.Visualize_Circle then
                      VisualzeMovement()
                  end
              elseif Random > 3 then
                  Client.Character.HumanoidRootPart.CFrame = Target.Character.HumanoidRootPart.CFrame * GetRandomCFrame(false, Settings.Misc.TargetStrafe.RandomizeMin, Settings.Misc.TargetStrafe.RandomizeMax)
                  if Settings.Misc.TargetStrafe.Visualize_Circle then
                      VisualzeMovement()
                  end
              end
  
          end
      end)
  end

  local function Reload(Object)
    local KOValue = Client.Character:WaitForChild('BodyEffects')['K.O'].Value

    if Object and KOValue ~= true then
        ReplicatedStorage:FindFirstChild('MainEvent'):FireServer('Reload', Object)
    end
end


  task.spawn(function()
    while task.wait(0.07) do

        if (enabled and Target and Target.Character and Settings.Misc.TargetStrafe.Enabled and Settings.Misc.TargetStrafe.AutoFire) then 

            local Gun = GetTool()
            if (Gun and Target) then 
                Gun:Activate()
            end
        end

        if (enabled and Target and Target.Character and Settings.Misc.TargetStrafe.Enabled and Settings.Misc.TargetStrafe.AutoReload) then

            local Gun = GetTool()
            if (Gun and Gun.Ammo.Value == 0) then
                Reload(Gun)
            end
        end
        
    end
  end)
  
    do -- walkspeed Cframe
        UserInputService.InputBegan:Connect(function(input, isTyping)
            if not isTyping and input.KeyCode == Settings.Misc.WalkSpeed.KeyBind and Settings.Misc.WalkSpeed.Enabled == true then
                if CFrameSpeedKeyBind then
                    CFrameSpeedKeyBind = false
                    Menu.Keybinds.List['CFrame']:Update(false and "On" or "Off")
                    if  Settings.Misc.WalkSpeed.Notifications == true then
                        Notifications:New('WalkSpeed disabled', 1.5, MainColor)
                    end
                else
                    Menu.Keybinds.List['CFrame']:Update(true and "On" or "Off")
                    CFrameSpeedKeyBind = true
                    if  Settings.Misc.WalkSpeed.Notifications == true then
                        Notifications:New('WalkSpeed enabled', 1.5, MainColor)
                    end
                end
            end
        end)
    end
  
    do -- fly
        UserInputService.InputBegan:Connect(function(input, isTyping)
            if not isTyping and input.KeyCode == Settings.Misc.Fly.KeyBind and Settings.Misc.Fly.Enabled then
                if flyvariableshit then
                    flyvariableshit = false
                    Menu.Keybinds.List['Fly']:Update(false and "On" or "Off")
                    if  Settings.Misc.Fly.Notification == true then
                        Notifications:New('fly disabled', 1.5, MainColor)
                    end
                else
                    flyvariableshit = true
                    Menu.Keybinds.List['Fly']:Update(true and "On" or "Off")
                    if  Settings.Misc.Fly.Notification == true then
                        Notifications:New('fly enabled', 1.5, MainColor)
                    end
                end
            end
        end)
    end
  
    do -- trash talk
        local function toggle_script(input, t)
            if not t and input.KeyCode == Settings.Misc.TrashTalk.Use.KeyBind and Settings.Misc.TrashTalk.Use.UsekeyBind then
                if Settings.Misc.TrashTalk.Use.Notification then
                    if not Settings.Misc.TrashTalk.Use.Enabled then
                        Notifications:New('trash talking', 1.5, MainColor)
                        if tick() >= chatSpamTick + 1 then
                            sayMessage(getgenv().MethodBeingUsed[math.random(1, #getgenv().MethodBeingUsed)])
                            chatSpamTick = tick()
                        end
                    else
                        Notifications:New('disabled "enabled" if you want to use', 1.5, MainColor)
                    end
                end
            end;
        end;
  
        UserInputService.InputBegan:Connect(toggle_script);
    end
  
    do -- // Anti Aim
        getgenv().xd = 0
  
        local function toggleScript()
        print("working")
        Settings.Misc.NetworkAnti.Enabled = not Settings.Misc.NetworkAnti.Enabled
            if Settings.Misc.NetworkAnti.Enabled then
                if Settings.Misc.NetworkAnti.Notification then
                    Notifications:New('Network enabled', 1.5, MainColor)
                end
            else
                if Settings.Misc.NetworkAnti.Notification then
                    Notifications:New('Network disabled', 1.5, MainColor)
                end
            end
        end
  
        UserInputService.InputBegan:Connect(function(input, t)
            if not t and input.KeyCode == Settings.Misc.NetworkAnti.Keybind then
                toggleScript()
            end
        end)
  
    task.spawn(function()
        while true do
            task.wait()
            if Settings.Misc.NetworkAnti.Enabled then
                local loop = RunService.Heartbeat:Connect(function()
                    sethiddenproperty(Client.Character.HumanoidRootPart, "NetworkIsSleeping", true)
                    task.wait()
                    sethiddenproperty(Client.Character.HumanoidRootPart, "NetworkIsSleeping", false)
                end)
                task.wait(getgenv().xd)
                if loop then
                    loop:Disconnect()
                end
            end
        end
    end)
  
    end

  
  local EtherealParts = Instance.new('Folder', workspace)
  EtherealParts.Name  = 'EtherealParts'
  
  local function HitEffect(Player, Type)
      local Character = Player.Character
      local RootPart  = Character and Character:FindFirstChild('HumanoidRootPart')
  
      if Character and RootPart then

        if Type == 'Pulse' then
			local Attachment = Instance.new('Attachment', RootPart)
			local Particle1  = Instance.new('ParticleEmitter', Attachment) do
				Particle1.Name          = 'Particle1'
				Particle1.LightEmission = 3
				Particle1.Transparency  = NumberSequence.new(0)
                Particle1.Color         = ColorSequence.new(MainColor)
				Particle1.Size          = NumberSequence.new{NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(1, 6, 1.2)}
				Particle1.Rotation      = NumberRange.new(0)
				Particle1.RotSpeed      = NumberRange.new(0)
				Particle1.Enabled       = false
				Particle1.Rate          = 2
				Particle1.Lifetime      = NumberRange.new(0.25)
				Particle1.Speed         = NumberRange.new(0.1)
				Particle1.Squash        = NumberSequence.new(0)
				Particle1.ZOffset       = 1
				Particle1.Texture       = 'rbxassetid://2916153928'
				Particle1.Orientation   = 'VelocityPerpendicular'
				Particle1.Shape         = 'Box'
				Particle1.ShapeInOut    = 'Outward'
				Particle1.ShapeStyle    = 'Volume'
			end
			local Particle2  = Instance.new('ParticleEmitter', Attachment) do
				Particle2.Name          = 'Particle1'
				Particle2.LightEmission = 3
				Particle2.Transparency  = NumberSequence.new(0)
                Particle2.Color         = ColorSequence.new(MainColor)
				Particle2.Size          = NumberSequence.new{NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(1, 6, 1.2)}
				Particle2.Rotation      = NumberRange.new(0)
				Particle2.RotSpeed      = NumberRange.new(0)
				Particle2.Enabled       = false
				Particle2.Rate          = 2
				Particle2.Lifetime      = NumberRange.new(0.25)
				Particle2.Speed         = NumberRange.new(0.1)
				Particle2.Squash        = NumberSequence.new(0)
				Particle2.ZOffset       = 1
				Particle2.Texture       = 'rbxassetid://2916153928'
				Particle2.Orientation   = 'FacingCamera'
				Particle2.Shape         = 'Box'
				Particle2.ShapeInOut    = 'Outward'
				Particle2.ShapeStyle    = 'Volume'
			end

			Particle1:Emit(1);
			Particle2:Emit(1);

			Debris:AddItem(Attachment, 1)
        elseif Type == 'Clone' then
  
              Character.Archivable  = true
  
              local Clone = Character:Clone()
              Clone.Parent = EtherealParts
              Clone.Humanoid.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
  
              for _, v in pairs(Clone:GetDescendants()) do
                  if (v:IsA('BasePart')) then
                      v.Material = Enum.Material.ForceField
                      v.Color = MainColor
                      v.CanCollide = false
                      v.Anchored = true
                      v.CanQuery = false
                      v.CanTouch = false
                  end
  
                  if (v:IsA('Accessory') or v:IsA('Tool')) then
                      v:Destroy()
                  end
              end
  
              for i,v in pairs(Character:GetDescendants()) do
                  if (v:IsA('BasePart')) then
                      local ClonePart = Clone:FindFirstChild(v.Name)
  
                      if (ClonePart) then
                          ClonePart.CFrame = v.CFrame
                      end
                  end
              end
  
              Clone:PivotTo(Character.PrimaryPart.CFrame + Vector3.new(Client.Character.HumanoidRootPart.CFrame.lookVector.x * 1.5, 0, Client.Character.HumanoidRootPart.CFrame.lookVector.z * 1.5))
  
              CharacterArchivable = false
              Debris:AddItem(Clone, 2)
  
          end
      end
  end
  
  local function FindTargetOnPart(Part)
      local Target = nil;
      local HitPart = nil;
      local Distance = 2;
  
      for _, Player in pairs(Players:GetPlayers()) do
          if (Player == Client) then continue end
  
          local Char = Player.Character
          local Root = Char and Char:FindFirstChild('HumanoidRootPart')
  
          for _, Obj in pairs(Char:GetChildren()) do
              if (not Obj:IsA('BasePart')) then continue end
  
              local Mag = (Obj.Position - Part.Position).magnitude
              if (Mag < Distance) then
                  Distance = Mag
                  Target = Player
                  HitPart = Obj
              end
          end
      end
  
      return Target, HitPart
  end
  
  local function SirenAdded(Obj)
      local Character = Client.Character
      local RootPart  = Character and Character:FindFirstChild('HumanoidRootPart')
  
      local function VerifyBullet(obj)
          return (obj.Name == 'BULLET_RAYS' or obj.Name:lower():find('bullet') or obj:WaitForChild('Attachment', 1) or obj:WaitForChild('GunBeam', 1)) and obj
      end 
  
      local PlayerChecks = {
          PlayerGun = false
      }
  
      local BulletRay = VerifyBullet(Obj)
      if (BulletRay and RootPart) then
          local Mag = (RootPart.Position - BulletRay.Position).magnitude
          local MagCheck = nil;
          if (Settings.Visuals.Hit_Detection.Enabled) then
              MagCheck = 13
          else
              MagCheck = 13
          end
  
          if (Mag <= MagCheck) then
              PlayerChecks.PlayerGun = true
          end
  
          if (PlayerChecks.PlayerGun) then -- Shot from client
              local GunBeam = BulletRay:WaitForChild('GunBeam', 1)
              local Attachment0 = GunBeam.Attachment0 -- closest to player
              local Attachment1 = GunBeam.Attachment1 -- mousepos 
  
              if Settings.Visuals.Bullet_Trails.Enabled then
                  task.wait()
                  GunBeam.Texture        = AssetTable.Textures[Settings.Visuals.Bullet_Trails.Texture]
                  GunBeam.LightEmission  = 5
                  GunBeam.Segments       = 10
                  GunBeam.LightInfluence = 0
                  GunBeam.TextureSpeed   = Settings.Visuals.Bullet_Trails.Speed
                  GunBeam.Brightness     = Settings.Visuals.Bullet_Trails.Brightness
                  GunBeam.Color          = Settings.Visuals.Bullet_Trails.Color
                  GunBeam.Width0         = Settings.Visuals.Bullet_Trails.Width
                  GunBeam.Width1         = Settings.Visuals.Bullet_Trails.Width
                  GunBeam.Transparency   = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)})
              end
  
              if Settings.Visuals.Hit_Detection.Enabled then
                  local Part = Instance.new('Part', Workspace); do
                      Part.Anchored = true
                      Part.Size = Vector3.new(0.25, 0.25, 0.25)
                      Part.Position = Attachment1.WorldCFrame.Position
                      Part.Material = Enum.Material.Neon
                      Part.Color = MainColor
                      Part.CanCollide = false
                      Part.Transparency = 1
                  end
  
                  Debris:AddItem(Part, 2)
  
                  local Target, HitPart = FindTargetOnPart(Part)
                  if (Target ~= nil) then
  
                      if Settings.Visuals.Hit_Detection.Notify then
                          Menu.Notify('Misery<font color="#' .. tostring(MainColor:ToHex()) .. '">.cc</font>  >  ' .. '+1 Hit | ' .. tostring(HitPart) .. ' | Target : ' .. Target.DisplayName .. '', 1.5)
                      end
  
                      if Settings.Visuals.Hit_Detection.Clone then
                          HitEffect(Target, 'Clone')
                      end

                      if Settings.Visuals.Hit_Detection.Pulse then
                        HitEffect(Target, 'Pulse')
                    end
  
                      if Settings.Visuals.Hit_Detection.Sound then
                          local Sound = Instance.new('Sound', Obj); do
                              Sound.SoundId = AssetTable.Sounds[Settings.Visuals.Hit_Detection.HitSound]
                              Sound.Volume = 1
                              Sound:Play()
                          end
                      end
  
                  end
              end
  
          end
      end
  
  end
  
  -- aim viewer
  do
    AntiAimViewer_Target = Client
    print(AntiAimViewer_Target)
  
  
      function getgun()
        for i, v in pairs(AntiAimViewer_Target.Character:GetChildren()) do
            if v and (v:FindFirstChild("Default") or v:FindFirstChild("Handle")) then
                return v
            end
        end
      end
  
      local a = Instance.new("Beam")
      a.Segments = 1
      a.Width0 = 0.2
      a.Width1 = 0.2
      a.Color = ColorSequence.new(AntiAimViewer_Color)
      a.FaceCamera = true
      local b = Instance.new("Attachment")
      local c = Instance.new("Attachment")
      a.Attachment0 = b
      a.Attachment1 = c
      a.Parent = workspace.Terrain
      b.Parent = workspace.Terrain
      c.Parent = workspace.Terrain
  
      task.spawn(
        function()
            RunService.RenderStepped:Connect(
                function()
                    local character = Client.Character
                    if not character then
                        a.Enabled = false
                        return
                    end
  
                    if
                        AntiAimViewer_Enabled and getgun() and
                            AntiAimViewer_Target.Character:FindFirstChild("BodyEffects") and
                            AntiAimViewer_Target.Character:FindFirstChild("Head") and
                            AntiAimViewer_Target.Character:FindFirstChildWhichIsA("Tool")
                    then
                        a.Enabled = true
                        b.Position = AntiAimViewer_Target.Character:FindFirstChild("Head").Position
                        c.Position = AntiAimViewer_Target.Character.BodyEffects[AntiAimViewer_Method].Value
                        a.Color = ColorSequence.new(AntiAimViewer_Color)
                    else
                        a.Enabled = false
                    end
                end
            )
        end
      )
  
  end
  
  
  --[[
  local HightLightT = Instance.new("Highlight")
  local AimViewerHighLight = Instance.new("Highlight")
  local Framework = Client.PlayerGui:FindFirstChild('Framework')
  
  local newindex; newindex = hookmetamethod(game, '__newindex', LPH_NO_VIRTUALIZE(function(self, key, value)
      local calling_script = getcallingscript()
  
      if (Framework and calling_script == Framework and self:IsA('Camera') and key == 'CFrame' and Settings.Misc.Random.NoRecoil) then 
          return 
      end
  
      if (key == 'WalkSpeed' and value < 16 and Settings.Misc.Random.NoSlow) then 
          value = 16
      end
  
      return newindex(self, key, value)
  end))
  ]]
  
  local function Heartbeat()

    UpdateFov()

    if Settings.Misc.Random.AntiBag then
        Client.Character["Christmas_Sock"]:Destroy()
    end
    if Settings.Misc.Random.AutoStomp then
        game.ReplicatedStorage.MainEvent:FireServer("Stomp")
    end
    if Settings.Misc.Cash.AutoDrop == true then
        game.ReplicatedStorage.MainEvent:FireServer("DropMoney", Settings.Misc.Cash.Amount)
    end
    if Settings.Misc.Cash.AutoPick == true then
        pcall(
            function()
                for _, v in pairs(Workspace.Ignored.Drop:GetChildren()) do
                    if v.Name == "MoneyDrop" then
                        local MoneyMagnitude =
                            (v.Position - Client.Character.HumanoidRootPart.Position).magnitude
                        if MoneyMagnitude < 25 then
                            fireclickdetector(v.ClickDetector)
                        end
                    end
                end
            end
        )
    end

    --[[

    if ENABLEDHIGHTLIGHTCHECK == true and Settings.Combat.Visuals.HighLight.Enabled == true and Settings.Combat.TargetLock.Enabled == true and Target then
        HightLightT.Parent = Target.Character
        HightLightT.FillColor = Settings.Combat.Visuals.HighLight.FillColor
        HightLightT.OutlineColor = Settings.Combat.Visuals.HighLight.OutLineColor
    else
        HightLightT.Parent = game.CoreGui
    end
]]  
    if AntiAimViewer_Enabled and AntiAimViewer_HighLight and AntiAimViewer_Target and AntiAimViewer_Target.Character and AntiAimViewer_Target.Character:FindFirstChild("HumanoidRootPart") then
        AimViewerHighLight.Parent = AntiAimViewer_Target.Character
        AimViewerHighLight.FillColor = AntiAimViewer_HighLight_FillColor
        AimViewerHighLight.OutlineColor = AntiAimViewer_HighLight_OutLineColor
    else
        AimViewerHighLight.Parent = game.CoreGui
    end
  
    if Settings.Combat.Visuals.Line.Enabled == true and Settings.Combat.TargetLock.Enabled == true and enabled and Target and Target.Character and Target.Character:FindFirstChild("HumanoidRootPart") then
        local mousePos = game:GetService("UserInputService"):GetMouseLocation()
        local ClosestPoint = Players[tostring(Target)].Character[Settings.Combat.TargetLock.HitParts]
        local ClosestPoint2D = Camera:WorldToViewportPoint(ClosestPoint.Position)
        Script.Drawing.Line.From = Vector2.new(ClosestPoint2D.X, ClosestPoint2D.Y)
        Script.Drawing.Line.To = Vector2.new(mousePos.X, mousePos.Y)
        Script.Drawing.Line.Visible = Settings.Combat.Visuals.Line.Visible
        Script.Drawing.Line.Thickness = Settings.Combat.Visuals.Line.Thickness
        Script.Drawing.Line.Color = Settings.Combat.Visuals.Line.Color
        Script.Drawing.Line.Transparency = Settings.Combat.Visuals.Line.Transparency
    else
        Script.Drawing.Line.To = Vector2.new(9999, 9999)
        Script.Drawing.Line.From = Vector2.new(9999, 9999)
        Script.Drawing.Line.Visible = Settings.Combat.Visuals.Line.Visible
        Script.Drawing.Line.Thickness = Settings.Combat.Visuals.Line.Thickness
        Script.Drawing.Line.Color = Settings.Combat.Visuals.Line.Color
        Script.Drawing.Line.Transparency = Settings.Combat.Visuals.Line.Transparency
    end
  
  
  
  
    if enabled and Target and Target.Character and Target.Character:FindFirstChild("LowerTorso") and Settings.Combat.Stuff.LookAt then
        Client.Character.HumanoidRootPart.CFrame = CFrame.new(Client.Character.HumanoidRootPart.CFrame.Position, Vector3.new(Target.Character.HumanoidRootPart.CFrame.X, Client.Character.HumanoidRootPart.CFrame.Position.Y, Target.Character.HumanoidRootPart.CFrame.Z))
    end
    if enabled and Target and Target.Character and Target.Character:FindFirstChild("LowerTorso") and Settings.Combat.Checks.Knocked == true then
        local KOd = Target.Character:WaitForChild("BodyEffects")["K.O"].Value
        local Grabbed = Target.Character:FindFirstChild("GRABBING_CONSTRAINT") ~= nil
        if KOd or Grabbed then
            print("knocked")
            ENABLEDHIGHTLIGHTCHECK = false
            enabled = false
            Target = nil
        end
    end
  
    if Settings.Combat.Stuff.AutoPrediction == true then
        pingvalue = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValueString()
        split = string.split(pingvalue,'(')
        ping = tonumber(split[1])
       if ping < 130 then
            Settings.Combat.TargetLock.Prediction = 0.151
       elseif ping < 125 then
            Settings.Combat.TargetLock.Prediction = 0.149
       elseif ping < 110 then
            Settings.Combat.TargetLock.Prediction = 0.146
       elseif ping < 105 then
            Settings.Combat.TargetLock.Prediction = 0.138
       elseif ping < 90 then
            Settings.Combat.TargetLock.Prediction = 0.136
       elseif ping < 80 then
            Settings.Combat.TargetLock.Prediction = 0.134
       elseif ping < 70 then
            Settings.Combat.TargetLock.Prediction = 0.131
       elseif ping < 60 then
            Settings.Combat.TargetLock.Prediction = 0.1229
       elseif ping < 50 then
            Settings.Combat.TargetLock.Prediction = 0.1225
       elseif ping < 40 then
            Settings.Combat.TargetLock.Prediction = 0.1256
       end
   end
  
   if CFrameSpeedKeyBind and Settings.Misc.WalkSpeed.Enabled then
        if Client.Character.Humanoid.MoveDirection.Magnitude > 0 then
            for i = 1, Settings.Misc.WalkSpeed.Speed do
                Client.Character:TranslateBy(Client.Character.Humanoid.MoveDirection)
            end
        end
    end
  
    if Settings.Misc.Fly.Enabled and flyvariableshit then
        spawn(function()
            pcall(function()
                local speed = Settings.Misc.Fly.Speed
                local velocity = Vector3.new(0, 1, 0)
                if UserInputService:IsKeyDown(Enum.KeyCode.W) then
                    velocity = velocity + (workspace.CurrentCamera.CoordinateFrame.lookVector * speed)
                end
                if UserInputService:IsKeyDown(Enum.KeyCode.A) then
                    velocity = velocity + (workspace.CurrentCamera.CoordinateFrame.rightVector * -speed)
                end
                if UserInputService:IsKeyDown(Enum.KeyCode.S) then
                    velocity = velocity + (workspace.CurrentCamera.CoordinateFrame.lookVector * -speed)
                end
                if UserInputService:IsKeyDown(Enum.KeyCode.D) then
                    velocity = velocity + (workspace.CurrentCamera.CoordinateFrame.rightVector * speed)
                end
  
                Client.Character.HumanoidRootPart.Velocity = velocity
                Client.Character.Humanoid:ChangeState("Freefall")
            end)
        end)
    else
        Client.Character.Humanoid:ChangeState("Landing")
    end
  
    if Settings.Misc.TrashTalk.Use.Enabled == true then
        if tick() >= chatSpamTick + 1 then
            sayMessage(getgenv().MethodBeingUsed[math.random(1, #getgenv().MethodBeingUsed)])
            chatSpamTick = tick()
        end
    end
  
  end
  
  
  --\\ Initialize Function
  local function Initialize()
    Menu.Watermark:SetVisible(true)
    Menu:SetTab("Main")
    Menu:SetVisible(true)
    Menu:Init()
    UserInputService.InputBegan:Connect(KeybindHandler)
    RunService.Heartbeat:Connect(Heartbeat)
    Workspace.Ignored.Siren.DescendantAdded:Connect(SirenAdded)
    ContextAction:BindAction('menuToggle', MenuToggle, false, Settings.Configs.Menu.Keybind)
  end
  do Initialize() end
  
  game:GetService("RunService").RenderStepped:Connect(function()

    local Character = Client and (Client.Character or Client.CharacterAdded:Wait())
    local Gun = GetTool(Gun)

    if Settings.Combat.Visuals.Line.Circle and Target and Target.Character then
        TargetCircle.Visible  = true
        TargetCircle.Position = Target.Character.UpperTorso and Target.Character.UpperTorso.Position
        TargetCircle.Color    = MainColor
        TargetCircle.Radius   = 2
        TargetCircle.Sides    = 2
    else
        TargetCircle.Visible  = false
    end
    
    if Settings.Visuals.Character_Chams.Enabled and Character then
        for i, v in pairs(Character:GetDescendants()) do
            if (v.Parent:IsA('Tool') and (v:IsA('MeshPart') or v:IsA('BasePart'))) then continue end 

            if v:IsA('MeshPart') then
                v.Material = Settings.Visuals.Character_Chams.Material
                v.Color = Settings.Visuals.Character_Chams.Color
                v.TextureID = ''
            end

            if v:IsA('BasePart') then
                v.Material = Settings.Visuals.Character_Chams.Material
                v.Color = Settings.Visuals.Character_Chams.Color
            end
        end
    end

    if Settings.Visuals.Weapon_Chams.Enabled and Character and Gun then
        for i, v in pairs(Gun:GetChildren()) do

            if v:IsA('MeshPart') then
                v.Material = Settings.Visuals.Weapon_Chams.Material
                v.Color = Settings.Visuals.Weapon_Chams.Color
                v.TextureID = ''
            end

            if v:IsA('BasePart') then
                v.Material = Settings.Visuals.Weapon_Chams.Material
                v.Color = Settings.Visuals.Weapon_Chams.Color
            end

        end
    end

    local Bars = Client.PlayerGui:FindFirstChild('MainScreenGui') and Client.PlayerGui.MainScreenGui:FindFirstChild('Bar')

    if (Bars) then 
        if Settings.Visuals.World_Customization.Bars then
            Bars.Energy.bar.BackgroundColor3 = Settings.Visuals.World_Customization.BarsColor
            Bars.Armor.bar.BackgroundColor3 = Settings.Visuals.World_Customization.BarsColor
            Bars.HP.bar.BackgroundColor3 = Settings.Visuals.World_Customization.BarsColor
            Bars.Armor.firebar.BackgroundColor3 = Settings.Visuals.World_Customization.BarsColor
        elseif not Settings.Visuals.World_Customization.Bars then
            Bars.Energy.bar.BackgroundColor3 = Color3.fromRGB(182, 182, 9)
            Bars.Armor.bar.BackgroundColor3 = Color3.fromRGB(0, 136, 194)
            Bars.HP.bar.BackgroundColor3 = Color3.fromRGB(36, 182, 3)
            Bars.Armor.firebar.BackgroundColor3 = Color3.fromRGB(253, 121, 33)
        end
    end

    UpdateIndicators()

    cam = workspace.CurrentCamera
end)

for i, v in next, (Players:GetChildren()) do
    if (v == Client) then continue end 
    
    local player = getgenv().esp.NewPlayer(v)
end

Players.PlayerAdded:Connect(function(v)
    local player = getgenv().esp.NewPlayer(v)
end)
